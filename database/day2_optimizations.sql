-- Day 2 Database Optimizations for AI Data Cleanup Core\n-- Optimizing transaction and category tables for AI workflow performance\n\n-- ============================================================================\n-- PERFORMANCE INDEXES FOR AI WORKFLOW\n-- ============================================================================\n\n-- Composite index for AI categorization queries\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_ai_workflow \nON transactions (accountant_id, status, ai_confidence) \nWHERE status = 'pending';\n\n-- Index for confidence-based filtering\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_confidence_status \nON transactions (ai_confidence, status, accountant_id) \nINCLUDE (transaction_date, amount, description);\n\n-- Index for bulk operations\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_bulk_approval \nON transactions (accountant_id, status, ai_confidence, ai_suggested_category_id) \nWHERE status = 'pending' AND ai_confidence IN ('high', 'medium');\n\n-- Index for transaction review dashboard\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_dashboard \nON transactions (accountant_id, status, transaction_date DESC) \nINCLUDE (amount, vendor_name, ai_confidence);\n\n-- Index for category lookup optimization\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_categories_active_lookup \nON transaction_categories (accountant_id, is_active, name) \nWHERE is_active = true;\n\n-- ============================================================================\n-- MATERIALIZED VIEW FOR DASHBOARD STATISTICS\n-- ============================================================================\n\nCREATE MATERIALIZED VIEW IF NOT EXISTS transaction_stats_by_accountant AS\nSELECT \n    accountant_id,\n    COUNT(*) as total_transactions,\n    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,\n    COUNT(*) FILTER (WHERE status = 'approved') as approved_count,\n    COUNT(*) FILTER (WHERE status = 'rejected') as rejected_count,\n    COUNT(*) FILTER (WHERE ai_confidence = 'high') as high_confidence_count,\n    COUNT(*) FILTER (WHERE ai_confidence = 'medium') as medium_confidence_count,\n    COUNT(*) FILTER (WHERE ai_confidence = 'low') as low_confidence_count,\n    COUNT(*) FILTER (WHERE status = 'approved' AND ai_confidence = 'high') as high_conf_approved,\n    COUNT(*) FILTER (WHERE status = 'approved' AND ai_confidence = 'medium') as medium_conf_approved,\n    COUNT(*) FILTER (WHERE status = 'approved' AND ai_confidence = 'low') as low_conf_approved,\n    ROUND(\n        (COUNT(*) FILTER (WHERE status = 'approved')::decimal / \n         NULLIF(COUNT(*) FILTER (WHERE status IN ('approved', 'rejected')), 0)) * 100, \n        2\n    ) as approval_rate,\n    MAX(updated_at) as last_activity\nFROM transactions \nGROUP BY accountant_id;\n\n-- Create index on materialized view\nCREATE UNIQUE INDEX IF NOT EXISTS idx_transaction_stats_accountant \nON transaction_stats_by_accountant (accountant_id);\n\n-- ============================================================================\n-- OPTIMIZED FUNCTIONS FOR AI WORKFLOW\n-- ============================================================================\n\n-- Function to get pending transactions for AI categorization\nCREATE OR REPLACE FUNCTION get_pending_transactions_for_ai(\n    p_accountant_id UUID,\n    p_confidence_filter TEXT DEFAULT NULL,\n    p_limit INTEGER DEFAULT 100\n)\nRETURNS TABLE (\n    id UUID,\n    description TEXT,\n    amount DECIMAL(12,2),\n    vendor_name TEXT,\n    transaction_date DATE,\n    account_name TEXT,\n    ai_confidence ai_confidence_level,\n    ai_reasoning TEXT,\n    category_name TEXT\n) \nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        t.id,\n        t.description,\n        t.amount,\n        t.vendor_name,\n        t.transaction_date,\n        t.account_name,\n        t.ai_confidence,\n        t.ai_reasoning,\n        tc.name as category_name\n    FROM transactions t\n    LEFT JOIN transaction_categories tc ON t.ai_suggested_category_id = tc.id\n    WHERE t.accountant_id = p_accountant_id\n      AND t.status = 'pending'\n      AND (p_confidence_filter IS NULL OR t.ai_confidence::text = p_confidence_filter)\n    ORDER BY \n        CASE t.ai_confidence \n            WHEN 'high' THEN 1\n            WHEN 'medium' THEN 2\n            WHEN 'low' THEN 3\n            ELSE 4\n        END,\n        t.transaction_date DESC\n    LIMIT p_limit;\nEND;\n$$;\n\n-- Function for bulk transaction approval\nCREATE OR REPLACE FUNCTION bulk_approve_transactions(\n    p_accountant_id UUID,\n    p_transaction_ids UUID[],\n    p_reviewed_by UUID\n)\nRETURNS TABLE (\n    transaction_id UUID,\n    success BOOLEAN,\n    error_message TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    t_id UUID;\n    update_count INTEGER;\nBEGIN\n    -- Process each transaction\n    FOREACH t_id IN ARRAY p_transaction_ids\n    LOOP\n        BEGIN\n            -- Update transaction status\n            UPDATE transactions \n            SET \n                status = 'approved',\n                category_id = ai_suggested_category_id,\n                reviewed_by = p_reviewed_by,\n                reviewed_at = NOW(),\n                updated_at = NOW()\n            WHERE id = t_id \n              AND accountant_id = p_accountant_id \n              AND status = 'pending'\n              AND ai_suggested_category_id IS NOT NULL;\n            \n            GET DIAGNOSTICS update_count = ROW_COUNT;\n            \n            IF update_count > 0 THEN\n                RETURN QUERY SELECT t_id, true, NULL::TEXT;\n            ELSE\n                RETURN QUERY SELECT t_id, false, 'Transaction not found or not eligible for approval';\n            END IF;\n            \n        EXCEPTION WHEN OTHERS THEN\n            RETURN QUERY SELECT t_id, false, SQLERRM;\n        END;\n    END LOOP;\nEND;\n$$;\n\n-- Function for bulk transaction rejection\nCREATE OR REPLACE FUNCTION bulk_reject_transactions(\n    p_accountant_id UUID,\n    p_transaction_ids UUID[],\n    p_reviewed_by UUID\n)\nRETURNS TABLE (\n    transaction_id UUID,\n    success BOOLEAN,\n    error_message TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    t_id UUID;\n    update_count INTEGER;\nBEGIN\n    -- Process each transaction\n    FOREACH t_id IN ARRAY p_transaction_ids\n    LOOP\n        BEGIN\n            -- Update transaction status\n            UPDATE transactions \n            SET \n                status = 'rejected',\n                reviewed_by = p_reviewed_by,\n                reviewed_at = NOW(),\n                updated_at = NOW()\n            WHERE id = t_id \n              AND accountant_id = p_accountant_id \n              AND status = 'pending';\n            \n            GET DIAGNOSTICS update_count = ROW_COUNT;\n            \n            IF update_count > 0 THEN\n                RETURN QUERY SELECT t_id, true, NULL::TEXT;\n            ELSE\n                RETURN QUERY SELECT t_id, false, 'Transaction not found or not eligible for rejection';\n            END IF;\n            \n        EXCEPTION WHEN OTHERS THEN\n            RETURN QUERY SELECT t_id, false, SQLERRM;\n        END;\n    END LOOP;\nEND;\n$$;\n\n-- Function to get AI categorization statistics\nCREATE OR REPLACE FUNCTION get_ai_categorization_stats(\n    p_accountant_id UUID,\n    p_days_back INTEGER DEFAULT 30\n)\nRETURNS TABLE (\n    total_categorized BIGINT,\n    high_confidence BIGINT,\n    medium_confidence BIGINT,\n    low_confidence BIGINT,\n    approval_rate DECIMAL(5,2),\n    avg_confidence_score DECIMAL(3,2),\n    categories_used BIGINT,\n    recent_activity JSONB\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    WITH stats AS (\n        SELECT \n            COUNT(*) as total,\n            COUNT(*) FILTER (WHERE ai_confidence = 'high') as high_conf,\n            COUNT(*) FILTER (WHERE ai_confidence = 'medium') as medium_conf,\n            COUNT(*) FILTER (WHERE ai_confidence = 'low') as low_conf,\n            COUNT(*) FILTER (WHERE status = 'approved') as approved,\n            COUNT(*) FILTER (WHERE status IN ('approved', 'rejected')) as reviewed,\n            COUNT(DISTINCT ai_suggested_category_id) as unique_categories\n        FROM transactions \n        WHERE accountant_id = p_accountant_id\n          AND ai_confidence IS NOT NULL\n          AND created_at >= NOW() - INTERVAL '1 day' * p_days_back\n    ),\n    recent AS (\n        SELECT jsonb_agg(\n            jsonb_build_object(\n                'date', transaction_date,\n                'count', count,\n                'avg_confidence', avg_confidence\n            ) ORDER BY transaction_date DESC\n        ) as activity\n        FROM (\n            SELECT \n                transaction_date,\n                COUNT(*) as count,\n                ROUND(AVG(\n                    CASE ai_confidence \n                        WHEN 'high' THEN 0.95\n                        WHEN 'medium' THEN 0.80\n                        WHEN 'low' THEN 0.50\n                        ELSE 0\n                    END\n                ), 2) as avg_confidence\n            FROM transactions \n            WHERE accountant_id = p_accountant_id\n              AND ai_confidence IS NOT NULL\n              AND created_at >= NOW() - INTERVAL '7 days'\n            GROUP BY transaction_date\n            ORDER BY transaction_date DESC\n            LIMIT 7\n        ) daily_stats\n    )\n    SELECT \n        s.total,\n        s.high_conf,\n        s.medium_conf,\n        s.low_conf,\n        CASE WHEN s.reviewed > 0 \n             THEN ROUND((s.approved::decimal / s.reviewed) * 100, 2)\n             ELSE 0 \n        END,\n        ROUND((\n            (s.high_conf * 0.95 + s.medium_conf * 0.80 + s.low_conf * 0.50) / \n            NULLIF(s.total, 0)\n        ), 2),\n        s.unique_categories,\n        COALESCE(r.activity, '[]'::jsonb)\n    FROM stats s\n    CROSS JOIN recent r;\nEND;\n$$;\n\n-- ============================================================================\n-- TRIGGERS FOR REAL-TIME STATISTICS\n-- ============================================================================\n\n-- Function to refresh materialized view on transaction changes\nCREATE OR REPLACE FUNCTION refresh_transaction_stats()\nRETURNS TRIGGER AS $$\nBEGIN\n    -- Refresh materialized view for affected accountant\n    REFRESH MATERIALIZED VIEW CONCURRENTLY transaction_stats_by_accountant;\n    RETURN COALESCE(NEW, OLD);\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Trigger to refresh stats on transaction updates\nDROP TRIGGER IF EXISTS trigger_refresh_transaction_stats ON transactions;\nCREATE TRIGGER trigger_refresh_transaction_stats\n    AFTER INSERT OR UPDATE OR DELETE ON transactions\n    FOR EACH STATEMENT\n    EXECUTE FUNCTION refresh_transaction_stats();\n\n-- ============================================================================\n-- PARTITIONING FOR LARGE DATASETS\n-- ============================================================================\n\n-- Create partitioned table for activity logs (if not exists)\nDO $$\nBEGIN\n    IF NOT EXISTS (\n        SELECT 1 FROM information_schema.tables \n        WHERE table_name = 'activity_logs_partitioned'\n    ) THEN\n        -- Create partitioned activity logs table\n        CREATE TABLE activity_logs_partitioned (\n            LIKE activity_logs INCLUDING ALL\n        ) PARTITION BY RANGE (created_at);\n        \n        -- Create monthly partitions for current and next 3 months\n        FOR i IN 0..3 LOOP\n            EXECUTE format(\n                'CREATE TABLE activity_logs_y%s_m%s PARTITION OF activity_logs_partitioned \n                 FOR VALUES FROM (%L) TO (%L)',\n                EXTRACT(YEAR FROM NOW() + INTERVAL '%s months', i),\n                LPAD(EXTRACT(MONTH FROM NOW() + INTERVAL '%s months', i)::text, 2, '0'),\n                DATE_TRUNC('month', NOW() + INTERVAL '%s months', i),\n                DATE_TRUNC('month', NOW() + INTERVAL '%s months', i + 1)\n            );\n        END LOOP;\n    END IF;\nEND\n$$;\n\n-- ============================================================================\n-- QUERY OPTIMIZATION VIEWS\n-- ============================================================================\n\n-- View for transaction review dashboard\nCREATE OR REPLACE VIEW transaction_review_dashboard AS\nSELECT \n    t.id,\n    t.accountant_id,\n    t.description,\n    t.amount,\n    t.vendor_name,\n    t.transaction_date,\n    t.account_name,\n    t.status,\n    t.ai_confidence,\n    t.ai_reasoning,\n    t.ai_suggested_category_id,\n    tc.name as suggested_category_name,\n    tc.category_type as suggested_category_type,\n    t.created_at,\n    t.updated_at,\n    -- Computed fields for UI\n    CASE t.ai_confidence \n        WHEN 'high' THEN 0.95\n        WHEN 'medium' THEN 0.80\n        WHEN 'low' THEN 0.50\n        ELSE 0\n    END as confidence_score,\n    CASE \n        WHEN t.ai_confidence = 'high' AND t.status = 'pending' THEN true\n        ELSE false\n    END as auto_approve_eligible\nFROM transactions t\nLEFT JOIN transaction_categories tc ON t.ai_suggested_category_id = tc.id\nWHERE t.ai_confidence IS NOT NULL;\n\n-- View for category usage statistics\nCREATE OR REPLACE VIEW category_usage_stats AS\nSELECT \n    tc.id,\n    tc.accountant_id,\n    tc.name,\n    tc.category_type,\n    COUNT(t.id) as usage_count,\n    COUNT(t.id) FILTER (WHERE t.status = 'approved') as approved_count,\n    COUNT(t.id) FILTER (WHERE t.ai_confidence = 'high') as high_confidence_count,\n    ROUND(\n        (COUNT(t.id) FILTER (WHERE t.status = 'approved')::decimal / \n         NULLIF(COUNT(t.id), 0)) * 100, \n        2\n    ) as approval_rate,\n    MAX(t.updated_at) as last_used\nFROM transaction_categories tc\nLEFT JOIN transactions t ON tc.id = t.ai_suggested_category_id\nWHERE tc.is_active = true\nGROUP BY tc.id, tc.accountant_id, tc.name, tc.category_type;\n\n-- ============================================================================\n-- PERFORMANCE MONITORING\n-- ============================================================================\n\n-- Function to analyze query performance\nCREATE OR REPLACE FUNCTION analyze_ai_workflow_performance()\nRETURNS TABLE (\n    query_type TEXT,\n    avg_duration_ms DECIMAL(10,2),\n    call_count BIGINT,\n    recommendation TEXT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    -- This would integrate with pg_stat_statements in production\n    RETURN QUERY\n    SELECT \n        'get_pending_transactions'::TEXT,\n        0.0::DECIMAL(10,2),\n        0::BIGINT,\n        'Monitor with pg_stat_statements'::TEXT;\nEND;\n$$;\n\n-- ============================================================================\n-- CLEANUP AND MAINTENANCE\n-- ============================================================================\n\n-- Function to archive old activity logs\nCREATE OR REPLACE FUNCTION archive_old_activity_logs(\n    p_days_to_keep INTEGER DEFAULT 90\n)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    deleted_count INTEGER;\nBEGIN\n    DELETE FROM activity_logs \n    WHERE created_at < NOW() - INTERVAL '1 day' * p_days_to_keep;\n    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    \n    RETURN deleted_count;\nEND;\n$$;\n\n-- Function to update table statistics\nCREATE OR REPLACE FUNCTION update_ai_workflow_stats()\nRETURNS VOID\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    -- Update table statistics for query planner\n    ANALYZE transactions;\n    ANALYZE transaction_categories;\n    ANALYZE activity_logs;\n    \n    -- Refresh materialized view\n    REFRESH MATERIALIZED VIEW CONCURRENTLY transaction_stats_by_accountant;\nEND;\n$$;\n\n-- ============================================================================\n-- COMMENTS FOR DOCUMENTATION\n-- ============================================================================\n\nCOMMENT ON FUNCTION get_pending_transactions_for_ai IS 'Optimized function to retrieve pending transactions for AI categorization with confidence-based ordering';\nCOMMENT ON FUNCTION bulk_approve_transactions IS 'Efficiently approve multiple transactions in a single operation with error handling';\nCOMMENT ON FUNCTION bulk_reject_transactions IS 'Efficiently reject multiple transactions in a single operation with error handling';\nCOMMENT ON FUNCTION get_ai_categorization_stats IS 'Comprehensive statistics for AI categorization performance and accuracy';\nCOMMENT ON MATERIALIZED VIEW transaction_stats_by_accountant IS 'Pre-computed statistics for dashboard performance';\nCOMMENT ON VIEW transaction_review_dashboard IS 'Optimized view for transaction review interface with computed fields';\nCOMMENT ON VIEW category_usage_stats IS 'Category usage analytics for improving AI accuracy';\n\n-- ============================================================================\n-- GRANT PERMISSIONS\n-- ============================================================================\n\n-- Grant execute permissions on functions to application role\n-- GRANT EXECUTE ON FUNCTION get_pending_transactions_for_ai TO app_role;\n-- GRANT EXECUTE ON FUNCTION bulk_approve_transactions TO app_role;\n-- GRANT EXECUTE ON FUNCTION bulk_reject_transactions TO app_role;\n-- GRANT EXECUTE ON FUNCTION get_ai_categorization_stats TO app_role;\n\n-- Grant select permissions on views\n-- GRANT SELECT ON transaction_review_dashboard TO app_role;\n-- GRANT SELECT ON category_usage_stats TO app_role;\n-- GRANT SELECT ON transaction_stats_by_accountant TO app_role;\n\nCOMMIT;\n"