-- Day 3 Database Optimizations for Receipt Processing & OCR\n-- Optimizing receipt storage, indexing, and matching performance\n\n-- ============================================================================\n-- RECEIPT STORAGE SCHEMA ENHANCEMENTS\n-- ============================================================================\n\n-- Add receipt processing status enum if not exists\nDO $$ BEGIN\n    CREATE TYPE receipt_processing_status AS ENUM (\n        'uploaded',\n        'queued', \n        'processing',\n        'processed',\n        'matched',\n        'error'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- Add OCR confidence level enum if not exists\nDO $$ BEGIN\n    CREATE TYPE ocr_confidence_level AS ENUM ('high', 'medium', 'low');\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- Enhance receipts table with additional columns for optimization\nALTER TABLE receipts \nADD COLUMN IF NOT EXISTS processing_status receipt_processing_status DEFAULT 'uploaded',\nADD COLUMN IF NOT EXISTS ocr_processing_started_at TIMESTAMPTZ,\nADD COLUMN IF NOT EXISTS ocr_processing_completed_at TIMESTAMPTZ,\nADD COLUMN IF NOT EXISTS ocr_processing_duration_ms INTEGER,\nADD COLUMN IF NOT EXISTS ocr_confidence_level ocr_confidence_level,\nADD COLUMN IF NOT EXISTS vendor_extracted_normalized TEXT, -- Normalized vendor name for matching\nADD COLUMN IF NOT EXISTS amount_extracted_cents BIGINT, -- Amount in cents for exact matching\nADD COLUMN IF NOT EXISTS date_extracted_normalized DATE, -- Normalized date for range queries\nADD COLUMN IF NOT EXISTS matching_attempted_at TIMESTAMPTZ,\nADD COLUMN IF NOT EXISTS matching_completed_at TIMESTAMPTZ,\nADD COLUMN IF NOT EXISTS auto_matched BOOLEAN DEFAULT FALSE,\nADD COLUMN IF NOT EXISTS manual_review_required BOOLEAN DEFAULT FALSE,\nADD COLUMN IF NOT EXISTS file_hash TEXT, -- For duplicate detection\nADD COLUMN IF NOT EXISTS thumbnail_path TEXT, -- For quick preview\nADD COLUMN IF NOT EXISTS search_vector tsvector; -- Full-text search\n\n-- ============================================================================\n-- PERFORMANCE INDEXES FOR RECEIPT PROCESSING\n-- ============================================================================\n\n-- Primary workflow indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_processing_status \nON receipts (processing_status, uploaded_at DESC) \nWHERE processing_status IN ('uploaded', 'queued', 'processing');\n\n-- OCR processing queue index\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_ocr_queue \nON receipts (uploaded_at ASC) \nWHERE processing_status = 'uploaded' AND ocr_processing_started_at IS NULL;\n\n-- Matching workflow indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_matching_queue \nON receipts (processed_at ASC) \nWHERE processing_status = 'processed' AND matching_attempted_at IS NULL;\n\n-- Client-specific receipt queries\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_client_status \nON receipts (client_id, processing_status, uploaded_at DESC);\n\n-- Accountant dashboard queries\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_accountant_review \nON receipts (client_id, manual_review_required, match_confidence DESC) \nWHERE manual_review_required = TRUE;\n\n-- Duplicate detection index\nCREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_file_hash \nON receipts (client_id, file_hash) \nWHERE file_hash IS NOT NULL;\n\n-- OCR data extraction indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_vendor_normalized \nON receipts USING gin(vendor_extracted_normalized gin_trgm_ops) \nWHERE vendor_extracted_normalized IS NOT NULL;\n\n-- Amount-based matching index\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_amount_date \nON receipts (amount_extracted_cents, date_extracted_normalized) \nWHERE amount_extracted_cents IS NOT NULL;\n\n-- Full-text search index\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_receipts_search_vector \nON receipts USING gin(search_vector);\n\n-- ============================================================================\n-- TRANSACTION MATCHING OPTIMIZATION INDEXES\n-- ============================================================================\n\n-- Enhanced transaction indexes for receipt matching\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_receipt_matching \nON transactions (accountant_id, transaction_date, amount) \nINCLUDE (vendor_name, description, account_name);\n\n-- Vendor name matching with trigram support\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_vendor_trgm \nON transactions USING gin(vendor_name gin_trgm_ops) \nWHERE vendor_name IS NOT NULL;\n\n-- Amount range matching index\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_amount_range \nON transactions (accountant_id, amount, transaction_date) \nWHERE amount IS NOT NULL;\n\n-- Unmatched transactions index\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_unmatched \nON transactions (accountant_id, transaction_date DESC) \nWHERE id NOT IN (SELECT transaction_id FROM receipts WHERE transaction_id IS NOT NULL);\n\n-- ============================================================================\n-- OPTIMIZED FUNCTIONS FOR RECEIPT PROCESSING\n-- ============================================================================\n\n-- Function to get next receipts for OCR processing\nCREATE OR REPLACE FUNCTION get_receipts_for_ocr_processing(\n    p_limit INTEGER DEFAULT 10\n)\nRETURNS TABLE (\n    id UUID,\n    client_id UUID,\n    file_path TEXT,\n    file_name TEXT,\n    mime_type TEXT,\n    uploaded_at TIMESTAMPTZ\n) \nLANGUAGE plpgsql\nAS $$\nBEGIN\n    -- Mark receipts as processing and return them\n    UPDATE receipts \n    SET \n        processing_status = 'processing',\n        ocr_processing_started_at = NOW(),\n        updated_at = NOW()\n    WHERE receipts.id IN (\n        SELECT receipts.id \n        FROM receipts \n        WHERE processing_status = 'uploaded' \n          AND ocr_processing_started_at IS NULL\n        ORDER BY uploaded_at ASC\n        LIMIT p_limit\n        FOR UPDATE SKIP LOCKED\n    );\n    \n    RETURN QUERY\n    SELECT \n        r.id,\n        r.client_id,\n        r.file_path,\n        r.file_name,\n        r.mime_type,\n        r.uploaded_at\n    FROM receipts r\n    WHERE r.processing_status = 'processing'\n      AND r.ocr_processing_started_at >= NOW() - INTERVAL '1 minute'\n    ORDER BY r.ocr_processing_started_at ASC;\nEND;\n$$;\n\n-- Function to update receipt with OCR results\nCREATE OR REPLACE FUNCTION update_receipt_ocr_results(\n    p_receipt_id UUID,\n    p_ocr_data JSONB,\n    p_vendor_extracted TEXT,\n    p_amount_extracted DECIMAL(12,2),\n    p_date_extracted DATE,\n    p_confidence DECIMAL(3,2),\n    p_processing_duration_ms INTEGER\n)\nRETURNS BOOLEAN\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_confidence_level ocr_confidence_level;\n    v_normalized_vendor TEXT;\n    v_amount_cents BIGINT;\n    v_search_text TEXT;\nBEGIN\n    -- Determine confidence level\n    IF p_confidence >= 0.8 THEN\n        v_confidence_level := 'high';\n    ELSIF p_confidence >= 0.6 THEN\n        v_confidence_level := 'medium';\n    ELSE\n        v_confidence_level := 'low';\n    END IF;\n    \n    -- Normalize vendor name for matching\n    v_normalized_vendor := LOWER(TRIM(REGEXP_REPLACE(p_vendor_extracted, '[^a-zA-Z0-9\\s]', '', 'g')));\n    \n    -- Convert amount to cents for exact matching\n    v_amount_cents := ROUND(p_amount_extracted * 100);\n    \n    -- Build search text for full-text search\n    v_search_text := COALESCE(p_vendor_extracted, '') || ' ' || \n                     COALESCE(p_amount_extracted::TEXT, '') || ' ' ||\n                     COALESCE(p_date_extracted::TEXT, '');\n    \n    -- Update receipt with OCR results\n    UPDATE receipts \n    SET \n        processing_status = 'processed',\n        ocr_data = p_ocr_data,\n        vendor_extracted = p_vendor_extracted,\n        amount_extracted = p_amount_extracted,\n        date_extracted = p_date_extracted,\n        ocr_confidence = p_confidence,\n        ocr_confidence_level = v_confidence_level,\n        vendor_extracted_normalized = v_normalized_vendor,\n        amount_extracted_cents = v_amount_cents,\n        date_extracted_normalized = p_date_extracted,\n        ocr_processing_completed_at = NOW(),\n        ocr_processing_duration_ms = p_processing_duration_ms,\n        processed_at = NOW(),\n        search_vector = to_tsvector('english', v_search_text),\n        updated_at = NOW()\n    WHERE id = p_receipt_id;\n    \n    RETURN FOUND;\nEND;\n$$;\n\n-- Function to find matching transactions for a receipt\nCREATE OR REPLACE FUNCTION find_matching_transactions(\n    p_receipt_id UUID,\n    p_accountant_id UUID,\n    p_date_range_days INTEGER DEFAULT 30,\n    p_amount_tolerance_percent DECIMAL(5,2) DEFAULT 5.0,\n    p_max_results INTEGER DEFAULT 10\n)\nRETURNS TABLE (\n    transaction_id UUID,\n    match_score DECIMAL(3,2),\n    match_reasons TEXT[],\n    transaction_description TEXT,\n    transaction_amount DECIMAL(12,2),\n    transaction_date DATE,\n    transaction_vendor TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_receipt RECORD;\n    v_amount_min DECIMAL(12,2);\n    v_amount_max DECIMAL(12,2);\n    v_date_min DATE;\n    v_date_max DATE;\nBEGIN\n    -- Get receipt details\n    SELECT \n        vendor_extracted,\n        amount_extracted,\n        date_extracted_normalized,\n        vendor_extracted_normalized\n    INTO v_receipt\n    FROM receipts \n    WHERE id = p_receipt_id;\n    \n    IF NOT FOUND THEN\n        RETURN;\n    END IF;\n    \n    -- Calculate search ranges\n    v_amount_min := v_receipt.amount_extracted * (1 - p_amount_tolerance_percent / 100);\n    v_amount_max := v_receipt.amount_extracted * (1 + p_amount_tolerance_percent / 100);\n    v_date_min := v_receipt.date_extracted_normalized - INTERVAL '1 day' * p_date_range_days;\n    v_date_max := v_receipt.date_extracted_normalized + INTERVAL '1 day' * p_date_range_days;\n    \n    RETURN QUERY\n    WITH transaction_matches AS (\n        SELECT \n            t.id,\n            t.description,\n            t.amount,\n            t.transaction_date,\n            t.vendor_name,\n            -- Calculate match score components\n            CASE \n                WHEN ABS(t.amount) = v_receipt.amount_extracted THEN 0.5\n                WHEN ABS(t.amount) BETWEEN v_amount_min AND v_amount_max THEN 0.3\n                ELSE 0.0\n            END as amount_score,\n            \n            CASE \n                WHEN t.transaction_date = v_receipt.date_extracted_normalized THEN 0.3\n                WHEN ABS(EXTRACT(DAYS FROM t.transaction_date - v_receipt.date_extracted_normalized)) <= 1 THEN 0.2\n                WHEN ABS(EXTRACT(DAYS FROM t.transaction_date - v_receipt.date_extracted_normalized)) <= 7 THEN 0.1\n                ELSE 0.0\n            END as date_score,\n            \n            CASE \n                WHEN t.vendor_name IS NOT NULL AND v_receipt.vendor_extracted_normalized IS NOT NULL THEN\n                    GREATEST(0, LEAST(0.2, \n                        similarity(\n                            LOWER(REGEXP_REPLACE(t.vendor_name, '[^a-zA-Z0-9\\s]', '', 'g')),\n                            v_receipt.vendor_extracted_normalized\n                        ) * 0.2\n                    ))\n                ELSE 0.0\n            END as vendor_score\n            \n        FROM transactions t\n        WHERE t.accountant_id = p_accountant_id\n          AND t.transaction_date BETWEEN v_date_min AND v_date_max\n          AND ABS(t.amount) BETWEEN v_amount_min * 0.5 AND v_amount_max * 2.0\n          AND t.id NOT IN (\n              SELECT transaction_id \n              FROM receipts \n              WHERE transaction_id IS NOT NULL\n          )\n    )\n    SELECT \n        tm.id,\n        (tm.amount_score + tm.date_score + tm.vendor_score)::DECIMAL(3,2) as total_score,\n        ARRAY[\n            CASE WHEN tm.amount_score > 0 THEN 'Amount match' END,\n            CASE WHEN tm.date_score > 0 THEN 'Date match' END,\n            CASE WHEN tm.vendor_score > 0 THEN 'Vendor similarity' END\n        ]::TEXT[] as reasons,\n        tm.description,\n        tm.amount,\n        tm.transaction_date,\n        tm.vendor_name\n    FROM transaction_matches tm\n    WHERE (tm.amount_score + tm.date_score + tm.vendor_score) > 0.3\n    ORDER BY (tm.amount_score + tm.date_score + tm.vendor_score) DESC\n    LIMIT p_max_results;\nEND;\n$$;\n\n-- Function to auto-match high-confidence receipts\nCREATE OR REPLACE FUNCTION auto_match_high_confidence_receipts(\n    p_accountant_id UUID,\n    p_confidence_threshold DECIMAL(3,2) DEFAULT 0.9\n)\nRETURNS TABLE (\n    receipt_id UUID,\n    transaction_id UUID,\n    match_score DECIMAL(3,2),\n    auto_matched BOOLEAN\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    WITH auto_matches AS (\n        SELECT \n            r.id as receipt_id,\n            matches.transaction_id,\n            matches.match_score\n        FROM receipts r\n        CROSS JOIN LATERAL (\n            SELECT * FROM find_matching_transactions(\n                r.id, \n                p_accountant_id, \n                30, -- 30 days range\n                5.0, -- 5% amount tolerance\n                1 -- Only get best match\n            )\n            WHERE match_score >= p_confidence_threshold\n            LIMIT 1\n        ) matches\n        WHERE r.client_id IN (\n            SELECT id FROM clients WHERE accountant_id = p_accountant_id\n        )\n        AND r.processing_status = 'processed'\n        AND r.transaction_id IS NULL\n        AND r.auto_matched = FALSE\n    )\n    UPDATE receipts \n    SET \n        transaction_id = am.transaction_id,\n        is_matched = TRUE,\n        match_confidence = am.match_score,\n        auto_matched = TRUE,\n        processing_status = 'matched',\n        updated_at = NOW()\n    FROM auto_matches am\n    WHERE receipts.id = am.receipt_id\n    RETURNING \n        receipts.id,\n        receipts.transaction_id,\n        receipts.match_confidence,\n        receipts.auto_matched;\nEND;\n$$;\n\n-- ============================================================================\n-- RECEIPT PROCESSING QUEUE MANAGEMENT\n-- ============================================================================\n\n-- Function to get OCR processing statistics\nCREATE OR REPLACE FUNCTION get_ocr_processing_stats(\n    p_accountant_id UUID DEFAULT NULL,\n    p_days_back INTEGER DEFAULT 7\n)\nRETURNS TABLE (\n    total_receipts BIGINT,\n    processed_receipts BIGINT,\n    pending_receipts BIGINT,\n    error_receipts BIGINT,\n    avg_processing_time_ms DECIMAL(10,2),\n    success_rate DECIMAL(5,2),\n    high_confidence_rate DECIMAL(5,2),\n    auto_match_rate DECIMAL(5,2)\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    WITH receipt_stats AS (\n        SELECT \n            COUNT(*) as total,\n            COUNT(*) FILTER (WHERE processing_status IN ('processed', 'matched')) as processed,\n            COUNT(*) FILTER (WHERE processing_status IN ('uploaded', 'queued', 'processing')) as pending,\n            COUNT(*) FILTER (WHERE processing_status = 'error') as errors,\n            AVG(ocr_processing_duration_ms) FILTER (WHERE ocr_processing_duration_ms IS NOT NULL) as avg_duration,\n            COUNT(*) FILTER (WHERE ocr_confidence_level = 'high') as high_conf,\n            COUNT(*) FILTER (WHERE auto_matched = TRUE) as auto_matched\n        FROM receipts r\n        WHERE (p_accountant_id IS NULL OR r.client_id IN (\n            SELECT id FROM clients WHERE accountant_id = p_accountant_id\n        ))\n        AND r.uploaded_at >= NOW() - INTERVAL '1 day' * p_days_back\n    )\n    SELECT \n        rs.total,\n        rs.processed,\n        rs.pending,\n        rs.errors,\n        rs.avg_duration,\n        CASE WHEN rs.total > 0 \n             THEN ROUND((rs.processed::decimal / rs.total) * 100, 2)\n             ELSE 0 \n        END,\n        CASE WHEN rs.processed > 0 \n             THEN ROUND((rs.high_conf::decimal / rs.processed) * 100, 2)\n             ELSE 0 \n        END,\n        CASE WHEN rs.processed > 0 \n             THEN ROUND((rs.auto_matched::decimal / rs.processed) * 100, 2)\n             ELSE 0 \n        END\n    FROM receipt_stats rs;\nEND;\n$$;\n\n-- ============================================================================\n-- TRIGGERS FOR AUTOMATED PROCESSING\n-- ============================================================================\n\n-- Function to trigger matching after OCR completion\nCREATE OR REPLACE FUNCTION trigger_receipt_matching()\nRETURNS TRIGGER AS $$\nBEGIN\n    -- If receipt was just processed, attempt auto-matching\n    IF OLD.processing_status != 'processed' AND NEW.processing_status = 'processed' THEN\n        -- Get accountant_id from client\n        DECLARE\n            v_accountant_id UUID;\n        BEGIN\n            SELECT accountant_id INTO v_accountant_id\n            FROM clients \n            WHERE id = NEW.client_id;\n            \n            -- Attempt auto-matching for high confidence receipts\n            IF NEW.ocr_confidence_level = 'high' THEN\n                PERFORM auto_match_high_confidence_receipts(v_accountant_id);\n            END IF;\n        END;\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create trigger for auto-matching\nDROP TRIGGER IF EXISTS trigger_auto_match_receipts ON receipts;\nCREATE TRIGGER trigger_auto_match_receipts\n    AFTER UPDATE ON receipts\n    FOR EACH ROW\n    EXECUTE FUNCTION trigger_receipt_matching();\n\n-- ============================================================================\n-- MATERIALIZED VIEWS FOR DASHBOARD PERFORMANCE\n-- ============================================================================\n\n-- Materialized view for receipt processing dashboard\nCREATE MATERIALIZED VIEW IF NOT EXISTS receipt_processing_dashboard AS\nSELECT \n    c.accountant_id,\n    COUNT(*) as total_receipts,\n    COUNT(*) FILTER (WHERE r.processing_status = 'uploaded') as uploaded_count,\n    COUNT(*) FILTER (WHERE r.processing_status = 'processing') as processing_count,\n    COUNT(*) FILTER (WHERE r.processing_status = 'processed') as processed_count,\n    COUNT(*) FILTER (WHERE r.processing_status = 'matched') as matched_count,\n    COUNT(*) FILTER (WHERE r.processing_status = 'error') as error_count,\n    COUNT(*) FILTER (WHERE r.manual_review_required = TRUE) as review_required_count,\n    COUNT(*) FILTER (WHERE r.auto_matched = TRUE) as auto_matched_count,\n    AVG(r.ocr_processing_duration_ms) FILTER (WHERE r.ocr_processing_duration_ms IS NOT NULL) as avg_processing_time,\n    MAX(r.uploaded_at) as last_upload,\n    MAX(r.processed_at) as last_processed\nFROM receipts r\nJOIN clients c ON r.client_id = c.id\nWHERE r.uploaded_at >= NOW() - INTERVAL '30 days'\nGROUP BY c.accountant_id;\n\n-- Create index on materialized view\nCREATE UNIQUE INDEX IF NOT EXISTS idx_receipt_dashboard_accountant \nON receipt_processing_dashboard (accountant_id);\n\n-- ============================================================================\n-- CLEANUP AND MAINTENANCE FUNCTIONS\n-- ============================================================================\n\n-- Function to clean up old receipt files\nCREATE OR REPLACE FUNCTION cleanup_old_receipts(\n    p_days_to_keep INTEGER DEFAULT 365\n)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    deleted_count INTEGER;\nBEGIN\n    -- Mark old receipts for deletion (don't actually delete to preserve audit trail)\n    UPDATE receipts \n    SET \n        file_path = NULL,\n        thumbnail_path = NULL,\n        updated_at = NOW()\n    WHERE uploaded_at < NOW() - INTERVAL '1 day' * p_days_to_keep\n      AND file_path IS NOT NULL;\n    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    \n    RETURN deleted_count;\nEND;\n$$;\n\n-- Function to refresh receipt processing statistics\nCREATE OR REPLACE FUNCTION refresh_receipt_stats()\nRETURNS VOID\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    -- Refresh materialized view\n    REFRESH MATERIALIZED VIEW CONCURRENTLY receipt_processing_dashboard;\n    \n    -- Update table statistics\n    ANALYZE receipts;\n    ANALYZE transactions;\nEND;\n$$;\n\n-- ============================================================================\n-- PERFORMANCE MONITORING VIEWS\n-- ============================================================================\n\n-- View for monitoring OCR processing performance\nCREATE OR REPLACE VIEW ocr_performance_monitor AS\nSELECT \n    DATE_TRUNC('hour', uploaded_at) as hour,\n    COUNT(*) as receipts_uploaded,\n    COUNT(*) FILTER (WHERE processing_status = 'processed') as receipts_processed,\n    COUNT(*) FILTER (WHERE processing_status = 'error') as receipts_failed,\n    AVG(ocr_processing_duration_ms) FILTER (WHERE ocr_processing_duration_ms IS NOT NULL) as avg_processing_time,\n    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY ocr_processing_duration_ms) FILTER (WHERE ocr_processing_duration_ms IS NOT NULL) as p95_processing_time,\n    COUNT(*) FILTER (WHERE ocr_confidence_level = 'high') as high_confidence_count,\n    COUNT(*) FILTER (WHERE auto_matched = TRUE) as auto_matched_count\nFROM receipts \nWHERE uploaded_at >= NOW() - INTERVAL '24 hours'\nGROUP BY DATE_TRUNC('hour', uploaded_at)\nORDER BY hour DESC;\n\n-- View for monitoring matching accuracy\nCREATE OR REPLACE VIEW matching_accuracy_monitor AS\nSELECT \n    DATE_TRUNC('day', processed_at) as day,\n    COUNT(*) as receipts_processed,\n    COUNT(*) FILTER (WHERE is_matched = TRUE) as receipts_matched,\n    COUNT(*) FILTER (WHERE auto_matched = TRUE) as auto_matched,\n    COUNT(*) FILTER (WHERE manual_review_required = TRUE) as manual_review_required,\n    AVG(match_confidence) FILTER (WHERE match_confidence IS NOT NULL) as avg_match_confidence,\n    COUNT(*) FILTER (WHERE match_confidence > 0.9) as high_confidence_matches,\n    COUNT(*) FILTER (WHERE match_confidence BETWEEN 0.7 AND 0.9) as medium_confidence_matches,\n    COUNT(*) FILTER (WHERE match_confidence < 0.7) as low_confidence_matches\nFROM receipts \nWHERE processed_at >= NOW() - INTERVAL '7 days'\n  AND processed_at IS NOT NULL\nGROUP BY DATE_TRUNC('day', processed_at)\nORDER BY day DESC;\n\n-- ============================================================================\n-- COMMENTS FOR DOCUMENTATION\n-- ============================================================================\n\nCOMMENT ON FUNCTION get_receipts_for_ocr_processing IS 'Atomically gets and marks receipts for OCR processing to prevent race conditions';\nCOMMENT ON FUNCTION update_receipt_ocr_results IS 'Updates receipt with OCR results and normalized data for efficient matching';\nCOMMENT ON FUNCTION find_matching_transactions IS 'Finds potential transaction matches using fuzzy matching algorithms';\nCOMMENT ON FUNCTION auto_match_high_confidence_receipts IS 'Automatically matches receipts with high confidence scores to reduce manual work';\nCOMMENT ON MATERIALIZED VIEW receipt_processing_dashboard IS 'Pre-computed dashboard statistics for receipt processing performance';\nCOMMENT ON VIEW ocr_performance_monitor IS 'Real-time monitoring of OCR processing performance and bottlenecks';\nCOMMENT ON VIEW matching_accuracy_monitor IS 'Tracking of matching accuracy and confidence distribution over time';\n\nCOMMIT;\n"