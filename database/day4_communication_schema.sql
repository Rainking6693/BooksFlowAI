-- Day 4 Database Schema for Client Communication & Notifications\n-- Messaging, notifications, and email automation infrastructure\n\n-- ============================================================================\n-- MESSAGING SYSTEM SCHEMA\n-- ============================================================================\n\n-- Message conversations table\nCREATE TABLE IF NOT EXISTS conversations (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,\n    accountant_id UUID NOT NULL REFERENCES accountants(id) ON DELETE CASCADE,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    last_message_at TIMESTAMPTZ,\n    last_message_preview TEXT,\n    is_archived BOOLEAN DEFAULT FALSE,\n    metadata JSONB DEFAULT '{}'\n);\n\n-- Messages table\nCREATE TABLE IF NOT EXISTS messages (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,\n    from_user_id UUID NOT NULL, -- Can be client_id or accountant_id\n    from_user_type user_type NOT NULL, -- 'client' or 'accountant'\n    to_user_id UUID NOT NULL,\n    to_user_type user_type NOT NULL,\n    message_type message_type DEFAULT 'text',\n    subject TEXT,\n    content TEXT NOT NULL,\n    sent_at TIMESTAMPTZ DEFAULT NOW(),\n    read_at TIMESTAMPTZ,\n    is_read BOOLEAN DEFAULT FALSE,\n    is_deleted BOOLEAN DEFAULT FALSE,\n    priority message_priority DEFAULT 'normal',\n    metadata JSONB DEFAULT '{}',\n    search_vector tsvector\n);\n\n-- Message attachments table\nCREATE TABLE IF NOT EXISTS message_attachments (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,\n    file_name TEXT NOT NULL,\n    file_path TEXT NOT NULL,\n    file_size BIGINT NOT NULL,\n    mime_type TEXT NOT NULL,\n    uploaded_at TIMESTAMPTZ DEFAULT NOW(),\n    metadata JSONB DEFAULT '{}'\n);\n\n-- Message types enum\nDO $$ BEGIN\n    CREATE TYPE message_type AS ENUM (\n        'text',\n        'file',\n        'system_notification',\n        'receipt_request',\n        'report_notification',\n        'reminder'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- Message priority enum\nDO $$ BEGIN\n    CREATE TYPE message_priority AS ENUM (\n        'low',\n        'normal',\n        'high',\n        'urgent'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- ============================================================================\n-- NOTIFICATIONS SYSTEM SCHEMA\n-- ============================================================================\n\n-- Notifications table\nCREATE TABLE IF NOT EXISTS notifications (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL, -- Can reference clients or accountants\n    user_type user_type NOT NULL,\n    notification_type notification_type NOT NULL,\n    title TEXT NOT NULL,\n    message TEXT NOT NULL,\n    priority notification_priority DEFAULT 'normal',\n    status notification_status DEFAULT 'unread',\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    read_at TIMESTAMPTZ,\n    expires_at TIMESTAMPTZ,\n    action_url TEXT,\n    action_text TEXT,\n    metadata JSONB DEFAULT '{}',\n    search_vector tsvector\n);\n\n-- Notification types enum\nDO $$ BEGIN\n    CREATE TYPE notification_type AS ENUM (\n        'info',\n        'success',\n        'warning',\n        'error',\n        'receipt_uploaded',\n        'receipt_processed',\n        'receipt_missing',\n        'report_ready',\n        'report_requested',\n        'message_received',\n        'reminder_sent',\n        'deadline_approaching',\n        'system_maintenance',\n        'account_update'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- Notification priority enum\nDO $$ BEGIN\n    CREATE TYPE notification_priority AS ENUM (\n        'low',\n        'normal',\n        'high',\n        'urgent'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- Notification status enum\nDO $$ BEGIN\n    CREATE TYPE notification_status AS ENUM (\n        'unread',\n        'read',\n        'dismissed',\n        'archived'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- ============================================================================\n-- EMAIL AUTOMATION SCHEMA\n-- ============================================================================\n\n-- Email templates table\nCREATE TABLE IF NOT EXISTS email_templates (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    template_name TEXT NOT NULL UNIQUE,\n    template_type email_template_type NOT NULL,\n    subject_template TEXT NOT NULL,\n    html_template TEXT NOT NULL,\n    text_template TEXT NOT NULL,\n    variables JSONB DEFAULT '{}', -- Template variables and their descriptions\n    is_active BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    created_by UUID, -- Reference to accountant who created template\n    metadata JSONB DEFAULT '{}'\n);\n\n-- Email template types enum\nDO $$ BEGIN\n    CREATE TYPE email_template_type AS ENUM (\n        'welcome',\n        'missing_receipt_reminder',\n        'report_ready',\n        'deadline_reminder',\n        'receipt_confirmation',\n        'monthly_summary',\n        'system_notification',\n        'custom'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- Email logs table for tracking sent emails\nCREATE TABLE IF NOT EXISTS email_logs (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    recipient_email TEXT NOT NULL,\n    recipient_name TEXT,\n    recipient_user_id UUID, -- Reference to client or accountant\n    sender_email TEXT NOT NULL,\n    sender_name TEXT,\n    email_type email_template_type NOT NULL,\n    template_id UUID REFERENCES email_templates(id),\n    subject TEXT NOT NULL,\n    sent_at TIMESTAMPTZ DEFAULT NOW(),\n    delivered_at TIMESTAMPTZ,\n    opened_at TIMESTAMPTZ,\n    clicked_at TIMESTAMPTZ,\n    bounced_at TIMESTAMPTZ,\n    status email_status DEFAULT 'sent',\n    message_id TEXT, -- External email service message ID\n    error_message TEXT,\n    metadata JSONB DEFAULT '{}'\n);\n\n-- Email status enum\nDO $$ BEGIN\n    CREATE TYPE email_status AS ENUM (\n        'queued',\n        'sent',\n        'delivered',\n        'opened',\n        'clicked',\n        'bounced',\n        'failed',\n        'spam'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- Email automation rules table\nCREATE TABLE IF NOT EXISTS email_automation_rules (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    rule_name TEXT NOT NULL,\n    accountant_id UUID REFERENCES accountants(id) ON DELETE CASCADE,\n    trigger_event TEXT NOT NULL, -- e.g., 'missing_receipt_detected', 'report_completed'\n    trigger_conditions JSONB DEFAULT '{}', -- Conditions for triggering\n    email_template_id UUID REFERENCES email_templates(id),\n    delay_hours INTEGER DEFAULT 0, -- Delay before sending\n    is_active BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    last_triggered_at TIMESTAMPTZ,\n    trigger_count INTEGER DEFAULT 0,\n    metadata JSONB DEFAULT '{}'\n);\n\n-- ============================================================================\n-- COMMUNICATION PREFERENCES SCHEMA\n-- ============================================================================\n\n-- User communication preferences\nCREATE TABLE IF NOT EXISTS communication_preferences (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL, -- Can reference clients or accountants\n    user_type user_type NOT NULL,\n    \n    -- Channel preferences\n    email_enabled BOOLEAN DEFAULT TRUE,\n    sms_enabled BOOLEAN DEFAULT FALSE,\n    push_enabled BOOLEAN DEFAULT TRUE,\n    in_app_enabled BOOLEAN DEFAULT TRUE,\n    \n    -- Notification type preferences\n    receipt_notifications BOOLEAN DEFAULT TRUE,\n    report_notifications BOOLEAN DEFAULT TRUE,\n    reminder_notifications BOOLEAN DEFAULT TRUE,\n    message_notifications BOOLEAN DEFAULT TRUE,\n    marketing_notifications BOOLEAN DEFAULT FALSE,\n    \n    -- Timing preferences\n    business_hours_only BOOLEAN DEFAULT FALSE,\n    timezone TEXT DEFAULT 'UTC',\n    quiet_hours_start TIME,\n    quiet_hours_end TIME,\n    \n    -- Frequency preferences\n    digest_frequency digest_frequency DEFAULT 'immediate',\n    reminder_frequency INTEGER DEFAULT 7, -- Days between reminders\n    \n    -- Contact information\n    phone_number TEXT,\n    preferred_language TEXT DEFAULT 'en',\n    \n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    metadata JSONB DEFAULT '{}'\n);\n\n-- Digest frequency enum\nDO $$ BEGIN\n    CREATE TYPE digest_frequency AS ENUM (\n        'immediate',\n        'hourly',\n        'daily',\n        'weekly',\n        'never'\n    );\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- ============================================================================\n-- PERFORMANCE INDEXES\n-- ============================================================================\n\n-- Conversation indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_conversations_client_accountant \nON conversations (client_id, accountant_id);\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_conversations_last_message \nON conversations (last_message_at DESC) \nWHERE is_archived = FALSE;\n\n-- Message indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_messages_conversation_sent \nON messages (conversation_id, sent_at DESC);\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_messages_recipient_unread \nON messages (to_user_id, to_user_type, is_read, sent_at DESC) \nWHERE is_read = FALSE AND is_deleted = FALSE;\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_messages_search_vector \nON messages USING gin(search_vector);\n\n-- Notification indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_notifications_user_status \nON notifications (user_id, user_type, status, created_at DESC);\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_notifications_type_priority \nON notifications (notification_type, priority, created_at DESC) \nWHERE status = 'unread';\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_notifications_expires \nON notifications (expires_at) \nWHERE expires_at IS NOT NULL AND status != 'archived';\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_notifications_search_vector \nON notifications USING gin(search_vector);\n\n-- Email log indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_email_logs_recipient_sent \nON email_logs (recipient_email, sent_at DESC);\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_email_logs_type_status \nON email_logs (email_type, status, sent_at DESC);\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_email_logs_message_id \nON email_logs (message_id) \nWHERE message_id IS NOT NULL;\n\n-- Communication preferences indexes\nCREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_comm_prefs_user \nON communication_preferences (user_id, user_type);\n\n-- ============================================================================\n-- OPTIMIZED FUNCTIONS FOR COMMUNICATION\n-- ============================================================================\n\n-- Function to get or create conversation between client and accountant\nCREATE OR REPLACE FUNCTION get_or_create_conversation(\n    p_client_id UUID,\n    p_accountant_id UUID\n)\nRETURNS UUID\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_conversation_id UUID;\nBEGIN\n    -- Try to find existing conversation\n    SELECT id INTO v_conversation_id\n    FROM conversations\n    WHERE client_id = p_client_id \n      AND accountant_id = p_accountant_id\n      AND is_archived = FALSE;\n    \n    -- Create new conversation if not found\n    IF v_conversation_id IS NULL THEN\n        INSERT INTO conversations (client_id, accountant_id)\n        VALUES (p_client_id, p_accountant_id)\n        RETURNING id INTO v_conversation_id;\n    END IF;\n    \n    RETURN v_conversation_id;\nEND;\n$$;\n\n-- Function to send a message\nCREATE OR REPLACE FUNCTION send_message(\n    p_conversation_id UUID,\n    p_from_user_id UUID,\n    p_from_user_type user_type,\n    p_to_user_id UUID,\n    p_to_user_type user_type,\n    p_content TEXT,\n    p_message_type message_type DEFAULT 'text',\n    p_priority message_priority DEFAULT 'normal',\n    p_metadata JSONB DEFAULT '{}'\n)\nRETURNS UUID\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_message_id UUID;\n    v_search_text TEXT;\nBEGIN\n    -- Build search text\n    v_search_text := p_content;\n    \n    -- Insert message\n    INSERT INTO messages (\n        conversation_id,\n        from_user_id,\n        from_user_type,\n        to_user_id,\n        to_user_type,\n        content,\n        message_type,\n        priority,\n        metadata,\n        search_vector\n    ) VALUES (\n        p_conversation_id,\n        p_from_user_id,\n        p_from_user_type,\n        p_to_user_id,\n        p_to_user_type,\n        p_content,\n        p_message_type,\n        p_priority,\n        p_metadata,\n        to_tsvector('english', v_search_text)\n    ) RETURNING id INTO v_message_id;\n    \n    -- Update conversation with last message info\n    UPDATE conversations \n    SET \n        last_message_at = NOW(),\n        last_message_preview = LEFT(p_content, 100),\n        updated_at = NOW()\n    WHERE id = p_conversation_id;\n    \n    -- Create notification for recipient\n    INSERT INTO notifications (\n        user_id,\n        user_type,\n        notification_type,\n        title,\n        message,\n        priority,\n        action_url,\n        action_text,\n        metadata\n    ) VALUES (\n        p_to_user_id,\n        p_to_user_type,\n        'message_received',\n        'New Message',\n        LEFT(p_content, 200),\n        CASE p_priority \n            WHEN 'urgent' THEN 'urgent'::notification_priority\n            WHEN 'high' THEN 'high'::notification_priority\n            ELSE 'normal'::notification_priority\n        END,\n        '/messages/' || p_conversation_id,\n        'View Message',\n        jsonb_build_object(\n            'messageId', v_message_id,\n            'conversationId', p_conversation_id,\n            'fromUserId', p_from_user_id\n        )\n    );\n    \n    RETURN v_message_id;\nEND;\n$$;\n\n-- Function to create notification\nCREATE OR REPLACE FUNCTION create_notification(\n    p_user_id UUID,\n    p_user_type user_type,\n    p_notification_type notification_type,\n    p_title TEXT,\n    p_message TEXT,\n    p_priority notification_priority DEFAULT 'normal',\n    p_action_url TEXT DEFAULT NULL,\n    p_action_text TEXT DEFAULT NULL,\n    p_expires_hours INTEGER DEFAULT NULL,\n    p_metadata JSONB DEFAULT '{}'\n)\nRETURNS UUID\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_notification_id UUID;\n    v_expires_at TIMESTAMPTZ;\n    v_search_text TEXT;\nBEGIN\n    -- Calculate expiration time\n    IF p_expires_hours IS NOT NULL THEN\n        v_expires_at := NOW() + INTERVAL '1 hour' * p_expires_hours;\n    END IF;\n    \n    -- Build search text\n    v_search_text := p_title || ' ' || p_message;\n    \n    -- Insert notification\n    INSERT INTO notifications (\n        user_id,\n        user_type,\n        notification_type,\n        title,\n        message,\n        priority,\n        action_url,\n        action_text,\n        expires_at,\n        metadata,\n        search_vector\n    ) VALUES (\n        p_user_id,\n        p_user_type,\n        p_notification_type,\n        p_title,\n        p_message,\n        p_priority,\n        p_action_url,\n        p_action_text,\n        v_expires_at,\n        p_metadata,\n        to_tsvector('english', v_search_text)\n    ) RETURNING id INTO v_notification_id;\n    \n    RETURN v_notification_id;\nEND;\n$$;\n\n-- Function to mark messages as read\nCREATE OR REPLACE FUNCTION mark_messages_as_read(\n    p_user_id UUID,\n    p_user_type user_type,\n    p_conversation_id UUID DEFAULT NULL,\n    p_message_ids UUID[] DEFAULT NULL\n)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_updated_count INTEGER;\nBEGIN\n    IF p_message_ids IS NOT NULL THEN\n        -- Mark specific messages as read\n        UPDATE messages \n        SET \n            is_read = TRUE,\n            read_at = NOW()\n        WHERE id = ANY(p_message_ids)\n          AND to_user_id = p_user_id\n          AND to_user_type = p_user_type\n          AND is_read = FALSE;\n    ELSIF p_conversation_id IS NOT NULL THEN\n        -- Mark all messages in conversation as read\n        UPDATE messages \n        SET \n            is_read = TRUE,\n            read_at = NOW()\n        WHERE conversation_id = p_conversation_id\n          AND to_user_id = p_user_id\n          AND to_user_type = p_user_type\n          AND is_read = FALSE;\n    ELSE\n        -- Mark all messages for user as read\n        UPDATE messages \n        SET \n            is_read = TRUE,\n            read_at = NOW()\n        WHERE to_user_id = p_user_id\n          AND to_user_type = p_user_type\n          AND is_read = FALSE;\n    END IF;\n    \n    GET DIAGNOSTICS v_updated_count = ROW_COUNT;\n    RETURN v_updated_count;\nEND;\n$$;\n\n-- Function to mark notifications as read\nCREATE OR REPLACE FUNCTION mark_notifications_as_read(\n    p_user_id UUID,\n    p_user_type user_type,\n    p_notification_ids UUID[] DEFAULT NULL\n)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_updated_count INTEGER;\nBEGIN\n    IF p_notification_ids IS NOT NULL THEN\n        -- Mark specific notifications as read\n        UPDATE notifications \n        SET \n            status = 'read',\n            read_at = NOW()\n        WHERE id = ANY(p_notification_ids)\n          AND user_id = p_user_id\n          AND user_type = p_user_type\n          AND status = 'unread';\n    ELSE\n        -- Mark all notifications for user as read\n        UPDATE notifications \n        SET \n            status = 'read',\n            read_at = NOW()\n        WHERE user_id = p_user_id\n          AND user_type = p_user_type\n          AND status = 'unread';\n    END IF;\n    \n    GET DIAGNOSTICS v_updated_count = ROW_COUNT;\n    RETURN v_updated_count;\nEND;\n$$;\n\n-- Function to get communication statistics\nCREATE OR REPLACE FUNCTION get_communication_stats(\n    p_user_id UUID,\n    p_user_type user_type,\n    p_days_back INTEGER DEFAULT 30\n)\nRETURNS TABLE (\n    unread_messages BIGINT,\n    unread_notifications BIGINT,\n    total_conversations BIGINT,\n    messages_sent BIGINT,\n    messages_received BIGINT,\n    notifications_created BIGINT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    WITH stats AS (\n        SELECT \n            -- Unread messages\n            COUNT(*) FILTER (\n                WHERE m.to_user_id = p_user_id \n                  AND m.to_user_type = p_user_type \n                  AND m.is_read = FALSE \n                  AND m.is_deleted = FALSE\n            ) as unread_msgs,\n            \n            -- Unread notifications\n            COUNT(*) FILTER (\n                WHERE n.user_id = p_user_id \n                  AND n.user_type = p_user_type \n                  AND n.status = 'unread'\n            ) as unread_notifs,\n            \n            -- Messages sent in period\n            COUNT(*) FILTER (\n                WHERE m.from_user_id = p_user_id \n                  AND m.from_user_type = p_user_type \n                  AND m.sent_at >= NOW() - INTERVAL '1 day' * p_days_back\n            ) as msgs_sent,\n            \n            -- Messages received in period\n            COUNT(*) FILTER (\n                WHERE m.to_user_id = p_user_id \n                  AND m.to_user_type = p_user_type \n                  AND m.sent_at >= NOW() - INTERVAL '1 day' * p_days_back\n            ) as msgs_received,\n            \n            -- Notifications created in period\n            COUNT(*) FILTER (\n                WHERE n.user_id = p_user_id \n                  AND n.user_type = p_user_type \n                  AND n.created_at >= NOW() - INTERVAL '1 day' * p_days_back\n            ) as notifs_created\n            \n        FROM messages m\n        FULL OUTER JOIN notifications n ON FALSE -- Cross join for counting\n        WHERE (m.from_user_id = p_user_id AND m.from_user_type = p_user_type)\n           OR (m.to_user_id = p_user_id AND m.to_user_type = p_user_type)\n           OR (n.user_id = p_user_id AND n.user_type = p_user_type)\n    ),\n    conversation_stats AS (\n        SELECT COUNT(DISTINCT c.id) as total_convs\n        FROM conversations c\n        WHERE (c.client_id = p_user_id AND p_user_type = 'client')\n           OR (c.accountant_id = p_user_id AND p_user_type = 'accountant')\n    )\n    SELECT \n        s.unread_msgs,\n        s.unread_notifs,\n        cs.total_convs,\n        s.msgs_sent,\n        s.msgs_received,\n        s.notifs_created\n    FROM stats s, conversation_stats cs;\nEND;\n$$;\n\n-- ============================================================================\n-- TRIGGERS FOR AUTOMATED PROCESSING\n-- ============================================================================\n\n-- Function to update conversation timestamp on new message\nCREATE OR REPLACE FUNCTION update_conversation_on_message()\nRETURNS TRIGGER AS $$\nBEGIN\n    UPDATE conversations \n    SET \n        last_message_at = NEW.sent_at,\n        last_message_preview = LEFT(NEW.content, 100),\n        updated_at = NOW()\n    WHERE id = NEW.conversation_id;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Trigger for updating conversation on new message\nDROP TRIGGER IF EXISTS trigger_update_conversation_on_message ON messages;\nCREATE TRIGGER trigger_update_conversation_on_message\n    AFTER INSERT ON messages\n    FOR EACH ROW\n    EXECUTE FUNCTION update_conversation_on_message();\n\n-- Function to clean up expired notifications\nCREATE OR REPLACE FUNCTION cleanup_expired_notifications()\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_deleted_count INTEGER;\nBEGIN\n    UPDATE notifications \n    SET status = 'archived'\n    WHERE expires_at < NOW() \n      AND status NOT IN ('archived', 'dismissed');\n    \n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    \n    RETURN v_deleted_count;\nEND;\n$$;\n\n-- ============================================================================\n-- MATERIALIZED VIEWS FOR DASHBOARD PERFORMANCE\n-- ============================================================================\n\n-- Communication dashboard view\nCREATE MATERIALIZED VIEW IF NOT EXISTS communication_dashboard AS\nSELECT \n    u.user_id,\n    u.user_type,\n    COUNT(DISTINCT c.id) as total_conversations,\n    COUNT(m.id) FILTER (WHERE m.sent_at >= NOW() - INTERVAL '7 days') as messages_last_7_days,\n    COUNT(m.id) FILTER (WHERE m.is_read = FALSE AND m.to_user_id = u.user_id) as unread_messages,\n    COUNT(n.id) FILTER (WHERE n.status = 'unread') as unread_notifications,\n    COUNT(n.id) FILTER (WHERE n.priority IN ('high', 'urgent') AND n.status = 'unread') as urgent_notifications,\n    MAX(m.sent_at) as last_message_at,\n    MAX(n.created_at) as last_notification_at\nFROM (\n    SELECT id as user_id, 'client'::user_type as user_type FROM clients\n    UNION ALL\n    SELECT id as user_id, 'accountant'::user_type as user_type FROM accountants\n) u\nLEFT JOIN conversations c ON \n    (u.user_type = 'client' AND c.client_id = u.user_id) OR\n    (u.user_type = 'accountant' AND c.accountant_id = u.user_id)\nLEFT JOIN messages m ON \n    (m.from_user_id = u.user_id AND m.from_user_type = u.user_type) OR\n    (m.to_user_id = u.user_id AND m.to_user_type = u.user_type)\nLEFT JOIN notifications n ON \n    n.user_id = u.user_id AND n.user_type = u.user_type\nGROUP BY u.user_id, u.user_type;\n\n-- Create index on materialized view\nCREATE UNIQUE INDEX IF NOT EXISTS idx_comm_dashboard_user \nON communication_dashboard (user_id, user_type);\n\n-- ============================================================================\n-- CLEANUP AND MAINTENANCE FUNCTIONS\n-- ============================================================================\n\n-- Function to archive old conversations\nCREATE OR REPLACE FUNCTION archive_old_conversations(\n    p_days_inactive INTEGER DEFAULT 365\n)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_archived_count INTEGER;\nBEGIN\n    UPDATE conversations \n    SET \n        is_archived = TRUE,\n        updated_at = NOW()\n    WHERE last_message_at < NOW() - INTERVAL '1 day' * p_days_inactive\n      AND is_archived = FALSE;\n    \n    GET DIAGNOSTICS v_archived_count = ROW_COUNT;\n    \n    RETURN v_archived_count;\nEND;\n$$;\n\n-- Function to clean up old email logs\nCREATE OR REPLACE FUNCTION cleanup_old_email_logs(\n    p_days_to_keep INTEGER DEFAULT 730 -- 2 years\n)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_deleted_count INTEGER;\nBEGIN\n    DELETE FROM email_logs \n    WHERE sent_at < NOW() - INTERVAL '1 day' * p_days_to_keep;\n    \n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    \n    RETURN v_deleted_count;\nEND;\n$$;\n\n-- Function to refresh communication statistics\nCREATE OR REPLACE FUNCTION refresh_communication_stats()\nRETURNS VOID\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    -- Refresh materialized view\n    REFRESH MATERIALIZED VIEW CONCURRENTLY communication_dashboard;\n    \n    -- Update table statistics\n    ANALYZE messages;\n    ANALYZE notifications;\n    ANALYZE conversations;\n    ANALYZE email_logs;\nEND;\n$$;\n\n-- ============================================================================\n-- PERFORMANCE MONITORING VIEWS\n-- ============================================================================\n\n-- View for monitoring message performance\nCREATE OR REPLACE VIEW message_performance_monitor AS\nSELECT \n    DATE_TRUNC('hour', sent_at) as hour,\n    COUNT(*) as messages_sent,\n    COUNT(*) FILTER (WHERE is_read = TRUE) as messages_read,\n    COUNT(*) FILTER (WHERE priority IN ('high', 'urgent')) as priority_messages,\n    AVG(EXTRACT(EPOCH FROM (read_at - sent_at))/60) FILTER (WHERE read_at IS NOT NULL) as avg_read_time_minutes,\n    COUNT(DISTINCT conversation_id) as active_conversations\nFROM messages \nWHERE sent_at >= NOW() - INTERVAL '24 hours'\n  AND is_deleted = FALSE\nGROUP BY DATE_TRUNC('hour', sent_at)\nORDER BY hour DESC;\n\n-- View for monitoring notification performance\nCREATE OR REPLACE VIEW notification_performance_monitor AS\nSELECT \n    DATE_TRUNC('hour', created_at) as hour,\n    notification_type,\n    COUNT(*) as notifications_created,\n    COUNT(*) FILTER (WHERE status = 'read') as notifications_read,\n    COUNT(*) FILTER (WHERE priority IN ('high', 'urgent')) as urgent_notifications,\n    AVG(EXTRACT(EPOCH FROM (read_at - created_at))/60) FILTER (WHERE read_at IS NOT NULL) as avg_read_time_minutes\nFROM notifications \nWHERE created_at >= NOW() - INTERVAL '24 hours'\nGROUP BY DATE_TRUNC('hour', created_at), notification_type\nORDER BY hour DESC, notification_type;\n\n-- View for monitoring email performance\nCREATE OR REPLACE VIEW email_performance_monitor AS\nSELECT \n    DATE_TRUNC('day', sent_at) as day,\n    email_type,\n    COUNT(*) as emails_sent,\n    COUNT(*) FILTER (WHERE status = 'delivered') as emails_delivered,\n    COUNT(*) FILTER (WHERE status = 'opened') as emails_opened,\n    COUNT(*) FILTER (WHERE status = 'clicked') as emails_clicked,\n    COUNT(*) FILTER (WHERE status = 'bounced') as emails_bounced,\n    COUNT(*) FILTER (WHERE status = 'failed') as emails_failed,\n    ROUND(COUNT(*) FILTER (WHERE status = 'delivered')::decimal / COUNT(*) * 100, 2) as delivery_rate,\n    ROUND(COUNT(*) FILTER (WHERE status = 'opened')::decimal / COUNT(*) FILTER (WHERE status = 'delivered') * 100, 2) as open_rate\nFROM email_logs \nWHERE sent_at >= NOW() - INTERVAL '7 days'\nGROUP BY DATE_TRUNC('day', sent_at), email_type\nORDER BY day DESC, email_type;\n\n-- ============================================================================\n-- COMMENTS FOR DOCUMENTATION\n-- ============================================================================\n\nCOMMENT ON TABLE conversations IS 'Conversation threads between clients and accountants';\nCOMMENT ON TABLE messages IS 'Individual messages within conversations with full-text search';\nCOMMENT ON TABLE notifications IS 'System notifications for users with priority and expiration';\nCOMMENT ON TABLE email_logs IS 'Audit trail of all emails sent through the system';\nCOMMENT ON TABLE email_templates IS 'Reusable email templates for automated communications';\nCOMMENT ON TABLE communication_preferences IS 'User preferences for notification channels and timing';\n\nCOMMENT ON FUNCTION send_message IS 'Sends a message and creates notification for recipient';\nCOMMENT ON FUNCTION create_notification IS 'Creates a notification with optional expiration and actions';\nCOMMENT ON FUNCTION mark_messages_as_read IS 'Marks messages as read and updates read timestamps';\nCOMMENT ON FUNCTION get_communication_stats IS 'Returns comprehensive communication statistics for a user';\n\nCOMMENT ON MATERIALIZED VIEW communication_dashboard IS 'Pre-computed communication statistics for dashboard performance';\nCOMMENT ON VIEW message_performance_monitor IS 'Real-time monitoring of message delivery and read rates';\nCOMMENT ON VIEW notification_performance_monitor IS 'Real-time monitoring of notification engagement';\nCOMMENT ON VIEW email_performance_monitor IS 'Email delivery and engagement analytics';\n\nCOMMIT;\n"