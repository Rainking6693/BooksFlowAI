import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { logger } from '@/lib/logger'\nimport { ValidationError, DatabaseError } from '@/lib/errors'\n\n// GET endpoint for analytics dashboard data\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const clientId = searchParams.get('clientId')\n    const accountantId = searchParams.get('accountantId')\n    const timeRange = searchParams.get('timeRange') || '30d'\n\n    if (!clientId && !accountantId) {\n      const error = new ValidationError('Either clientId or accountantId is required')\n      logger.error('Analytics API validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Calculate date range\n    const endDate = new Date()\n    const startDate = new Date()\n    \n    switch (timeRange) {\n      case '7d':\n        startDate.setDate(endDate.getDate() - 7)\n        break\n      case '30d':\n        startDate.setDate(endDate.getDate() - 30)\n        break\n      case '90d':\n        startDate.setDate(endDate.getDate() - 90)\n        break\n      case '1y':\n        startDate.setFullYear(endDate.getFullYear() - 1)\n        break\n      default:\n        startDate.setDate(endDate.getDate() - 30)\n    }\n\n    if (clientId) {\n      return await getClientAnalytics(clientId, startDate, endDate, timeRange)\n    } else {\n      return await getAccountantAnalytics(accountantId!, startDate, endDate, timeRange)\n    }\n\n  } catch (error) {\n    logger.error('Analytics API service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error fetching analytics' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Get analytics data for a specific client\n */\nasync function getClientAnalytics(\n  clientId: string,\n  startDate: Date,\n  endDate: Date,\n  timeRange: string\n) {\n  try {\n    // Get overview metrics\n    const overview = await getOverviewMetrics(clientId, startDate, endDate)\n    \n    // Get trend data\n    const trends = await getTrendData(clientId, startDate, endDate, timeRange)\n    \n    // Get category breakdown\n    const categories = await getCategoryBreakdown(clientId, startDate, endDate)\n    \n    // Get receipt metrics\n    const receipts = await getReceiptMetrics(clientId, startDate, endDate)\n    \n    // Get performance metrics\n    const performance = await getPerformanceMetrics(clientId, startDate, endDate)\n    \n    // Get AI insights\n    const insights = await getAIInsights(clientId, overview, categories)\n\n    const analyticsData = {\n      overview,\n      trends,\n      categories,\n      receipts,\n      performance,\n      insights,\n      metadata: {\n        clientId,\n        timeRange,\n        startDate: startDate.toISOString(),\n        endDate: endDate.toISOString(),\n        generatedAt: new Date().toISOString()\n      }\n    }\n\n    logger.info('Client analytics generated successfully', {\n      clientId,\n      timeRange,\n      dataPoints: {\n        trends: trends.incomeData.length,\n        categories: categories.length,\n        insights: insights.length\n      }\n    })\n\n    return NextResponse.json(analyticsData)\n\n  } catch (error) {\n    const dbError = new DatabaseError('Failed to fetch client analytics', {\n      clientId,\n      timeRange,\n      dbError: error instanceof Error ? error.message : 'Unknown error'\n    })\n    logger.error('Database error in client analytics', dbError)\n    return NextResponse.json(\n      { error: dbError.message },\n      { status: dbError.statusCode }\n    )\n  }\n}\n\n/**\n * Get analytics data for an accountant (all their clients)\n */\nasync function getAccountantAnalytics(\n  accountantId: string,\n  startDate: Date,\n  endDate: Date,\n  timeRange: string\n) {\n  try {\n    // Get all clients for this accountant\n    const { data: clients, error: clientsError } = await supabase\n      .from('clients')\n      .select('id, name')\n      .eq('accountant_id', accountantId)\n\n    if (clientsError) {\n      throw new Error(`Failed to fetch clients: ${clientsError.message}`)\n    }\n\n    if (!clients || clients.length === 0) {\n      return NextResponse.json({\n        overview: getEmptyOverview(),\n        trends: getEmptyTrends(),\n        categories: [],\n        receipts: getEmptyReceipts(),\n        performance: getEmptyPerformance(),\n        insights: [],\n        clients: [],\n        metadata: {\n          accountantId,\n          timeRange,\n          startDate: startDate.toISOString(),\n          endDate: endDate.toISOString(),\n          generatedAt: new Date().toISOString()\n        }\n      })\n    }\n\n    // Aggregate data across all clients\n    const clientIds = clients.map(c => c.id)\n    \n    const overview = await getAggregatedOverview(clientIds, startDate, endDate)\n    const trends = await getAggregatedTrends(clientIds, startDate, endDate, timeRange)\n    const categories = await getAggregatedCategories(clientIds, startDate, endDate)\n    const receipts = await getAggregatedReceipts(clientIds, startDate, endDate)\n    const performance = await getAggregatedPerformance(clientIds, startDate, endDate)\n    const insights = await getAccountantInsights(clientIds, overview, categories)\n\n    const analyticsData = {\n      overview,\n      trends,\n      categories,\n      receipts,\n      performance,\n      insights,\n      clients: clients.map(client => ({\n        id: client.id,\n        name: client.name\n      })),\n      metadata: {\n        accountantId,\n        timeRange,\n        clientCount: clients.length,\n        startDate: startDate.toISOString(),\n        endDate: endDate.toISOString(),\n        generatedAt: new Date().toISOString()\n      }\n    }\n\n    logger.info('Accountant analytics generated successfully', {\n      accountantId,\n      timeRange,\n      clientCount: clients.length,\n      dataPoints: {\n        trends: trends.incomeData.length,\n        categories: categories.length,\n        insights: insights.length\n      }\n    })\n\n    return NextResponse.json(analyticsData)\n\n  } catch (error) {\n    const dbError = new DatabaseError('Failed to fetch accountant analytics', {\n      accountantId,\n      timeRange,\n      dbError: error instanceof Error ? error.message : 'Unknown error'\n    })\n    logger.error('Database error in accountant analytics', dbError)\n    return NextResponse.json(\n      { error: dbError.message },\n      { status: dbError.statusCode }\n    )\n  }\n}\n\n/**\n * Get overview metrics for a client\n */\nasync function getOverviewMetrics(clientId: string, startDate: Date, endDate: Date) {\n  const { data: transactions, error } = await supabase\n    .from('transactions')\n    .select('amount, category, date')\n    .eq('client_id', clientId)\n    .gte('date', startDate.toISOString().split('T')[0])\n    .lte('date', endDate.toISOString().split('T')[0])\n\n  if (error) {\n    throw new Error(`Failed to fetch transactions: ${error.message}`)\n  }\n\n  const currentIncome = transactions\n    ?.filter(t => t.amount > 0)\n    .reduce((sum, t) => sum + t.amount, 0) || 0\n\n  const currentExpenses = transactions\n    ?.filter(t => t.amount < 0)\n    .reduce((sum, t) => sum + Math.abs(t.amount), 0) || 0\n\n  const currentProfit = currentIncome - currentExpenses\n  const profitMargin = currentIncome > 0 ? (currentProfit / currentIncome) * 100 : 0\n\n  // Calculate growth rates (compare with previous period)\n  const periodDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))\n  const previousStartDate = new Date(startDate.getTime() - (periodDays * 24 * 60 * 60 * 1000))\n  const previousEndDate = new Date(startDate.getTime() - 1)\n\n  const { data: previousTransactions } = await supabase\n    .from('transactions')\n    .select('amount')\n    .eq('client_id', clientId)\n    .gte('date', previousStartDate.toISOString().split('T')[0])\n    .lte('date', previousEndDate.toISOString().split('T')[0])\n\n  const previousIncome = previousTransactions\n    ?.filter(t => t.amount > 0)\n    .reduce((sum, t) => sum + t.amount, 0) || 0\n\n  const previousExpenses = previousTransactions\n    ?.filter(t => t.amount < 0)\n    .reduce((sum, t) => sum + Math.abs(t.amount), 0) || 0\n\n  const incomeGrowthRate = previousIncome > 0 \n    ? ((currentIncome - previousIncome) / previousIncome) * 100 \n    : 0\n\n  const expenseGrowthRate = previousExpenses > 0 \n    ? ((currentExpenses - previousExpenses) / previousExpenses) * 100 \n    : 0\n\n  return {\n    currentIncome,\n    currentExpenses,\n    currentProfit,\n    incomeGrowthRate,\n    expenseGrowthRate,\n    profitMargin\n  }\n}\n\n/**\n * Get trend data for charts\n */\nasync function getTrendData(clientId: string, startDate: Date, endDate: Date, timeRange: string) {\n  // Determine grouping interval based on time range\n  const groupBy = timeRange === '7d' ? 'day' : timeRange === '30d' ? 'week' : 'month'\n  \n  const { data: dailyMetrics, error } = await supabase\n    .from('daily_financial_metrics')\n    .select('date, total_income, total_expenses')\n    .eq('client_id', clientId)\n    .gte('date', startDate.toISOString().split('T')[0])\n    .lte('date', endDate.toISOString().split('T')[0])\n    .order('date')\n\n  if (error) {\n    throw new Error(`Failed to fetch daily metrics: ${error.message}`)\n  }\n\n  // Group data by the specified interval\n  const groupedData = groupDataByInterval(dailyMetrics || [], groupBy)\n  \n  return {\n    incomeData: groupedData.map(item => ({\n      month: item.period,\n      amount: item.income\n    })),\n    expenseData: groupedData.map(item => ({\n      month: item.period,\n      amount: item.expenses\n    })),\n    profitData: groupedData.map(item => ({\n      month: item.period,\n      amount: item.income - item.expenses\n    }))\n  }\n}\n\n/**\n * Get category breakdown\n */\nasync function getCategoryBreakdown(clientId: string, startDate: Date, endDate: Date) {\n  const { data: transactions, error } = await supabase\n    .from('transactions')\n    .select('amount, category')\n    .eq('client_id', clientId)\n    .lt('amount', 0) // Only expenses\n    .gte('date', startDate.toISOString().split('T')[0])\n    .lte('date', endDate.toISOString().split('T')[0])\n\n  if (error) {\n    throw new Error(`Failed to fetch category data: ${error.message}`)\n  }\n\n  // Group by category\n  const categoryTotals = (transactions || []).reduce((acc: Record<string, number>, transaction) => {\n    const category = transaction.category || 'Uncategorized'\n    acc[category] = (acc[category] || 0) + Math.abs(transaction.amount)\n    return acc\n  }, {})\n\n  const totalExpenses = Object.values(categoryTotals).reduce((sum, amount) => sum + amount, 0)\n\n  return Object.entries(categoryTotals)\n    .map(([name, amount]) => ({\n      name,\n      amount,\n      percentage: totalExpenses > 0 ? Math.round((amount / totalExpenses) * 100) : 0,\n      trend: 'stable' as const // TODO: Calculate actual trend\n    }))\n    .sort((a, b) => b.amount - a.amount)\n    .slice(0, 10) // Top 10 categories\n}\n\n/**\n * Get receipt metrics\n */\nasync function getReceiptMetrics(clientId: string, startDate: Date, endDate: Date) {\n  const { data: receipts, error } = await supabase\n    .from('receipts')\n    .select('status, created_at')\n    .eq('client_id', clientId)\n    .gte('created_at', startDate.toISOString())\n    .lte('created_at', endDate.toISOString())\n\n  if (error) {\n    throw new Error(`Failed to fetch receipt metrics: ${error.message}`)\n  }\n\n  const thisMonth = receipts?.length || 0\n  const pending = receipts?.filter(r => r.status === 'pending').length || 0\n  const processed = receipts?.filter(r => r.status === 'processed').length || 0\n  const accuracy = processed > 0 ? Math.round((processed / thisMonth) * 100) : 0\n\n  return {\n    thisMonth,\n    pending,\n    processed,\n    accuracy\n  }\n}\n\n/**\n * Get performance metrics\n */\nasync function getPerformanceMetrics(clientId: string, startDate: Date, endDate: Date) {\n  // This would typically come from performance tracking tables\n  // For now, return sample data\n  return {\n    accuracyScore: 94,\n    avgProcessingTime: 1200, // milliseconds\n    automationRate: 87,\n    clientSatisfaction: 4.6\n  }\n}\n\n/**\n * Generate AI insights based on the data\n */\nasync function getAIInsights(clientId: string, overview: any, categories: any[]) {\n  const insights = []\n\n  // Profit margin insight\n  if (overview.profitMargin < 10) {\n    insights.push({\n      type: 'warning' as const,\n      title: 'Low Profit Margin',\n      description: `Your profit margin is ${overview.profitMargin.toFixed(1)}%, which is below the recommended 15-20% for most businesses.`,\n      impact: overview.currentIncome * 0.1,\n      actionable: true\n    })\n  }\n\n  // Growth opportunity\n  if (overview.incomeGrowthRate > 10) {\n    insights.push({\n      type: 'achievement' as const,\n      title: 'Strong Income Growth',\n      description: `Your income has grown by ${overview.incomeGrowthRate.toFixed(1)}% compared to the previous period.`,\n      impact: overview.currentIncome - (overview.currentIncome / (1 + overview.incomeGrowthRate / 100)),\n      actionable: false\n    })\n  }\n\n  // Category optimization\n  const topCategory = categories[0]\n  if (topCategory && topCategory.percentage > 30) {\n    insights.push({\n      type: 'opportunity' as const,\n      title: 'Expense Optimization Opportunity',\n      description: `${topCategory.name} represents ${topCategory.percentage}% of your expenses. Consider reviewing these costs for potential savings.`,\n      impact: topCategory.amount * 0.1,\n      actionable: true\n    })\n  }\n\n  return insights\n}\n\n/**\n * Helper function to group data by time interval\n */\nfunction groupDataByInterval(data: any[], groupBy: 'day' | 'week' | 'month') {\n  // Implementation would depend on the specific grouping logic\n  // For now, return the data as-is with formatted periods\n  return data.map(item => ({\n    period: new Date(item.date).toLocaleDateString('en-US', {\n      month: 'short',\n      ...(groupBy === 'day' && { day: 'numeric' })\n    }),\n    income: item.total_income || 0,\n    expenses: item.total_expenses || 0\n  }))\n}\n\n/**\n * Helper functions for empty data states\n */\nfunction getEmptyOverview() {\n  return {\n    currentIncome: 0,\n    currentExpenses: 0,\n    currentProfit: 0,\n    incomeGrowthRate: 0,\n    expenseGrowthRate: 0,\n    profitMargin: 0\n  }\n}\n\nfunction getEmptyTrends() {\n  return {\n    incomeData: [],\n    expenseData: [],\n    profitData: []\n  }\n}\n\nfunction getEmptyReceipts() {\n  return {\n    thisMonth: 0,\n    pending: 0,\n    processed: 0,\n    accuracy: 0\n  }\n}\n\nfunction getEmptyPerformance() {\n  return {\n    accuracyScore: 0,\n    avgProcessingTime: 0,\n    automationRate: 0,\n    clientSatisfaction: 0\n  }\n}\n\n/**\n * Aggregated functions for accountant analytics\n */\nasync function getAggregatedOverview(clientIds: string[], startDate: Date, endDate: Date) {\n  // Implementation for aggregating across multiple clients\n  // This would sum up all client metrics\n  return getEmptyOverview() // Placeholder\n}\n\nasync function getAggregatedTrends(clientIds: string[], startDate: Date, endDate: Date, timeRange: string) {\n  // Implementation for aggregating trends across clients\n  return getEmptyTrends() // Placeholder\n}\n\nasync function getAggregatedCategories(clientIds: string[], startDate: Date, endDate: Date) {\n  // Implementation for aggregating categories across clients\n  return [] // Placeholder\n}\n\nasync function getAggregatedReceipts(clientIds: string[], startDate: Date, endDate: Date) {\n  // Implementation for aggregating receipt metrics\n  return getEmptyReceipts() // Placeholder\n}\n\nasync function getAggregatedPerformance(clientIds: string[], startDate: Date, endDate: Date) {\n  // Implementation for aggregating performance metrics\n  return getEmptyPerformance() // Placeholder\n}\n\nasync function getAccountantInsights(clientIds: string[], overview: any, categories: any[]) {\n  // Implementation for accountant-specific insights\n  return [] // Placeholder\n}\n"