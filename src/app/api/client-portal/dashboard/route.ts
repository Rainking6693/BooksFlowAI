import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { logger } from '@/lib/logger'\nimport { ValidationError, DatabaseError } from '@/lib/errors'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const clientId = searchParams.get('clientId')\n\n    if (!clientId) {\n      const error = new ValidationError('Missing clientId parameter')\n      logger.error('Client portal dashboard validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Get client information with accountant details\n    const { data: client, error: clientError } = await supabase\n      .from('clients')\n      .select(`\n        id,\n        name,\n        email,\n        accountant:accountants!inner(\n          id,\n          name,\n          email,\n          phone\n        )\n      `)\n      .eq('id', clientId)\n      .single()\n\n    if (clientError || !client) {\n      const error = new DatabaseError('Client not found', {\n        clientId,\n        dbError: clientError?.message\n      })\n      logger.error('Client lookup failed', error)\n      return NextResponse.json(\n        { error: 'Client not found' },\n        { status: 404 }\n      )\n    }\n\n    // Get recent reports\n    const { data: reports, error: reportsError } = await supabase\n      .from('reports')\n      .select('id, title, period_start, period_end, generated_at, status, file_url')\n      .eq('client_id', clientId)\n      .order('generated_at', { ascending: false })\n      .limit(10)\n\n    if (reportsError) {\n      logger.error('Error fetching reports', reportsError)\n    }\n\n    // Get pending receipts (transactions without receipts)\n    const { data: pendingReceipts, error: pendingError } = await supabase\n      .from('transactions')\n      .select('id, description, amount, transaction_date')\n      .eq('accountant_id', client.accountant.id)\n      .is('receipt_id', null)\n      .gte('transaction_date', new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]) // Last 90 days\n      .order('transaction_date', { ascending: false })\n      .limit(20)\n\n    if (pendingError) {\n      logger.error('Error fetching pending receipts', pendingError)\n    }\n\n    // Get recent activity\n    const { data: activity, error: activityError } = await supabase\n      .from('activity_logs')\n      .select('id, action, resource_type, created_at, new_values')\n      .eq('user_id', clientId)\n      .order('created_at', { ascending: false })\n      .limit(10)\n\n    if (activityError) {\n      logger.error('Error fetching activity', activityError)\n    }\n\n    // Get receipt statistics\n    const { data: receiptStats, error: statsError } = await supabase\n      .from('receipts')\n      .select('id, uploaded_at, processed_at')\n      .eq('client_id', clientId)\n      .gte('uploaded_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) // Last 30 days\n\n    if (statsError) {\n      logger.error('Error fetching receipt stats', statsError)\n    }\n\n    // Calculate statistics\n    const currentMonth = new Date().getMonth()\n    const currentYear = new Date().getFullYear()\n    \n    const receiptsThisMonth = receiptStats?.filter(receipt => {\n      const uploadDate = new Date(receipt.uploaded_at)\n      return uploadDate.getMonth() === currentMonth && uploadDate.getFullYear() === currentYear\n    }).length || 0\n\n    const receiptsProcessed = receiptStats?.filter(receipt => receipt.processed_at).length || 0\n    const pendingReceiptsCount = pendingReceipts?.length || 0\n    \n    const lastReport = reports?.[0]\n    const lastReportDate = lastReport ? lastReport.generated_at : new Date().toISOString()\n\n    // Format the response\n    const dashboardData = {\n      client: {\n        id: client.id,\n        name: client.name,\n        email: client.email,\n        accountant: {\n          name: client.accountant.name,\n          email: client.accountant.email,\n          phone: client.accountant.phone\n        }\n      },\n      recentReports: reports?.map(report => ({\n        id: report.id,\n        title: report.title,\n        period: `${new Date(report.period_start).toLocaleDateString()} - ${new Date(report.period_end).toLocaleDateString()}`,\n        generatedAt: report.generated_at,\n        status: report.status,\n        downloadUrl: report.file_url\n      })) || [],\n      pendingReceipts: pendingReceipts?.map(receipt => {\n        const daysOverdue = Math.floor(\n          (Date.now() - new Date(receipt.transaction_date).getTime()) / (1000 * 60 * 60 * 24)\n        )\n        return {\n          id: receipt.id,\n          description: receipt.description,\n          amount: Math.abs(receipt.amount),\n          date: receipt.transaction_date,\n          daysOverdue\n        }\n      }) || [],\n      recentActivity: activity?.map(act => {\n        let description = ''\n        let type = act.action.toLowerCase()\n        \n        switch (act.action) {\n          case 'RECEIPT_UPLOAD':\n            description = `Uploaded receipt: ${act.new_values?.fileName || 'Unknown file'}`\n            type = 'receipt_uploaded'\n            break\n          case 'REPORT_GENERATED':\n            description = 'Monthly report generated'\n            type = 'report_generated'\n            break\n          case 'MESSAGE_SENT':\n            description = 'Message sent to accountant'\n            type = 'message_received'\n            break\n          case 'REMINDER_SENT':\n            description = 'Receipt reminder sent'\n            type = 'reminder_sent'\n            break\n          default:\n            description = `${act.action.replace('_', ' ').toLowerCase()}`\n        }\n        \n        return {\n          id: act.id,\n          type,\n          description,\n          timestamp: act.created_at\n        }\n      }) || [],\n      stats: {\n        receiptsThisMonth,\n        receiptsProcessed,\n        pendingReceipts: pendingReceiptsCount,\n        lastReportDate\n      }\n    }\n\n    logger.info('Client portal dashboard loaded', {\n      clientId,\n      receiptsThisMonth,\n      receiptsProcessed,\n      pendingReceipts: pendingReceiptsCount,\n      reportsCount: reports?.length || 0\n    })\n\n    return NextResponse.json(dashboardData)\n\n  } catch (error) {\n    logger.error('Client portal dashboard service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error loading dashboard' },\n      { status: 500 }\n    )\n  }\n}\n\n// POST endpoint for client actions (messages, etc.)\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { clientId, action, data } = body\n\n    if (!clientId || !action) {\n      const error = new ValidationError('Missing clientId or action')\n      logger.error('Client portal action validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Verify client exists\n    const { data: client, error: clientError } = await supabase\n      .from('clients')\n      .select('id, accountant_id')\n      .eq('id', clientId)\n      .single()\n\n    if (clientError || !client) {\n      return NextResponse.json(\n        { error: 'Client not found' },\n        { status: 404 }\n      )\n    }\n\n    switch (action) {\n      case 'send_message':\n        return await handleSendMessage(clientId, client.accountant_id, data)\n      \n      case 'request_report':\n        return await handleRequestReport(clientId, client.accountant_id, data)\n      \n      case 'mark_notification_read':\n        return await handleMarkNotificationRead(clientId, data)\n      \n      default:\n        return NextResponse.json(\n          { error: 'Unknown action' },\n          { status: 400 }\n        )\n    }\n\n  } catch (error) {\n    logger.error('Client portal action service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error processing action' },\n      { status: 500 }\n    )\n  }\n}\n\n// Handle sending a message to accountant\nasync function handleSendMessage(clientId: string, accountantId: string, data: any) {\n  const { message } = data\n\n  if (!message || !message.trim()) {\n    return NextResponse.json(\n      { error: 'Message content is required' },\n      { status: 400 }\n    )\n  }\n\n  // Create message record\n  const { data: messageRecord, error: messageError } = await supabase\n    .from('messages')\n    .insert({\n      from_client_id: clientId,\n      to_accountant_id: accountantId,\n      message: message.trim(),\n      sent_at: new Date().toISOString(),\n      read: false\n    })\n    .select()\n    .single()\n\n  if (messageError) {\n    logger.error('Error creating message', messageError)\n    return NextResponse.json(\n      { error: 'Failed to send message' },\n      { status: 500 }\n    )\n  }\n\n  // Log activity\n  await supabase.from('activity_logs').insert({\n    user_id: clientId,\n    action: 'MESSAGE_SENT',\n    resource_type: 'message',\n    resource_id: messageRecord.id,\n    new_values: {\n      message: message.trim(),\n      toAccountant: accountantId\n    }\n  })\n\n  // TODO: Send email notification to accountant\n  // await sendEmailNotification(accountantId, 'new_message', { clientId, message })\n\n  logger.info('Message sent from client to accountant', {\n    clientId,\n    accountantId,\n    messageId: messageRecord.id\n  })\n\n  return NextResponse.json({\n    success: true,\n    message: 'Message sent successfully',\n    messageId: messageRecord.id\n  })\n}\n\n// Handle requesting a report\nasync function handleRequestReport(clientId: string, accountantId: string, data: any) {\n  const { reportType, period } = data\n\n  // Create report request\n  const { data: requestRecord, error: requestError } = await supabase\n    .from('report_requests')\n    .insert({\n      client_id: clientId,\n      accountant_id: accountantId,\n      report_type: reportType || 'monthly',\n      requested_period: period,\n      requested_at: new Date().toISOString(),\n      status: 'pending'\n    })\n    .select()\n    .single()\n\n  if (requestError) {\n    logger.error('Error creating report request', requestError)\n    return NextResponse.json(\n      { error: 'Failed to request report' },\n      { status: 500 }\n    )\n  }\n\n  // Log activity\n  await supabase.from('activity_logs').insert({\n    user_id: clientId,\n    action: 'REPORT_REQUESTED',\n    resource_type: 'report_request',\n    resource_id: requestRecord.id,\n    new_values: {\n      reportType,\n      period\n    }\n  })\n\n  logger.info('Report requested by client', {\n    clientId,\n    accountantId,\n    requestId: requestRecord.id,\n    reportType,\n    period\n  })\n\n  return NextResponse.json({\n    success: true,\n    message: 'Report request submitted successfully',\n    requestId: requestRecord.id\n  })\n}\n\n// Handle marking notification as read\nasync function handleMarkNotificationRead(clientId: string, data: any) {\n  const { notificationId } = data\n\n  if (!notificationId) {\n    return NextResponse.json(\n      { error: 'Notification ID is required' },\n      { status: 400 }\n    )\n  }\n\n  const { error: updateError } = await supabase\n    .from('notifications')\n    .update({ read: true, read_at: new Date().toISOString() })\n    .eq('id', notificationId)\n    .eq('user_id', clientId)\n\n  if (updateError) {\n    logger.error('Error marking notification as read', updateError)\n    return NextResponse.json(\n      { error: 'Failed to update notification' },\n      { status: 500 }\n    )\n  }\n\n  return NextResponse.json({\n    success: true,\n    message: 'Notification marked as read'\n  })\n}\n"