import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { logger } from '@/lib/logger'\nimport { ValidationError, DatabaseError, AuthorizationError } from '@/lib/errors'\nimport { verifyUserPermissions } from '@/lib/auth/permissions'\n\n// GET endpoint for audit trail data\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const userId = searchParams.get('userId')\n    const userRole = searchParams.get('userRole')\n    const startDate = searchParams.get('startDate')\n    const endDate = searchParams.get('endDate')\n    const eventType = searchParams.get('eventType')\n    const entityType = searchParams.get('entityType')\n    const riskLevel = searchParams.get('riskLevel')\n    const page = parseInt(searchParams.get('page') || '1')\n    const limit = parseInt(searchParams.get('limit') || '50')\n\n    // Verify user has audit access permissions\n    const hasPermission = await verifyUserPermissions(userId!, ['audit_read', 'compliance_view'])\n    if (!hasPermission) {\n      throw new AuthorizationError('Insufficient permissions to access audit trail')\n    }\n\n    // Build query filters\n    let query = supabase\n      .from('audit_trail')\n      .select(`\n        id,\n        event_id,\n        event_type,\n        event_category,\n        event_timestamp,\n        user_id,\n        user_type,\n        user_role,\n        ip_address,\n        entity_type,\n        entity_id,\n        entity_name,\n        action_performed,\n        old_values,\n        new_values,\n        change_summary,\n        compliance_framework,\n        risk_level,\n        requires_approval,\n        approval_status,\n        approved_by,\n        approved_at,\n        data_hash,\n        metadata\n      `)\n      .order('event_timestamp', { ascending: false })\n\n    // Apply filters\n    if (startDate) {\n      query = query.gte('event_timestamp', startDate)\n    }\n    if (endDate) {\n      query = query.lte('event_timestamp', endDate)\n    }\n    if (eventType) {\n      query = query.eq('event_type', eventType)\n    }\n    if (entityType) {\n      query = query.eq('entity_type', entityType)\n    }\n    if (riskLevel) {\n      query = query.eq('risk_level', riskLevel)\n    }\n\n    // Apply pagination\n    const offset = (page - 1) * limit\n    query = query.range(offset, offset + limit - 1)\n\n    const { data: auditEntries, error, count } = await query\n\n    if (error) {\n      throw new DatabaseError('Failed to fetch audit trail', {\n        dbError: error.message,\n        filters: { startDate, endDate, eventType, entityType, riskLevel }\n      })\n    }\n\n    // Get summary statistics\n    const summaryStats = await getAuditSummaryStats(startDate, endDate, eventType, entityType)\n\n    // Log audit trail access\n    await createAuditEntry({\n      eventType: 'data_export',\n      eventCategory: 'compliance',\n      userId: userId!,\n      userType: userRole as 'client' | 'accountant',\n      entityType: 'audit_trail',\n      entityId: null,\n      action: 'read',\n      complianceFrameworks: ['sox'],\n      riskLevel: 'medium',\n      metadata: {\n        filters: { startDate, endDate, eventType, entityType, riskLevel },\n        resultCount: auditEntries?.length || 0\n      }\n    })\n\n    const response = {\n      audit_entries: auditEntries || [],\n      pagination: {\n        page,\n        limit,\n        total: count || 0,\n        total_pages: Math.ceil((count || 0) / limit)\n      },\n      summary: summaryStats,\n      metadata: {\n        generated_at: new Date().toISOString(),\n        filters_applied: {\n          start_date: startDate,\n          end_date: endDate,\n          event_type: eventType,\n          entity_type: entityType,\n          risk_level: riskLevel\n        }\n      }\n    }\n\n    logger.info('Audit trail data retrieved successfully', {\n      userId,\n      resultCount: auditEntries?.length || 0,\n      filters: { startDate, endDate, eventType, entityType, riskLevel }\n    })\n\n    return NextResponse.json(response)\n\n  } catch (error) {\n    if (error instanceof AuthorizationError) {\n      logger.warn('Unauthorized audit trail access attempt', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    if (error instanceof ValidationError || error instanceof DatabaseError) {\n      logger.error('Audit trail API error', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    logger.error('Unexpected audit trail API error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error retrieving audit trail' },\n      { status: 500 }\n    )\n  }\n}\n\n// POST endpoint for creating audit entries\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const {\n      eventType,\n      eventCategory,\n      userId,\n      userType,\n      entityType,\n      entityId,\n      action,\n      oldValues,\n      newValues,\n      complianceFrameworks,\n      riskLevel,\n      metadata\n    } = body\n\n    // Validate required fields\n    if (!eventType || !eventCategory || !userId || !userType || !entityType || !action) {\n      throw new ValidationError('Missing required audit entry fields')\n    }\n\n    // Verify user has audit write permissions\n    const hasPermission = await verifyUserPermissions(userId, ['audit_write', 'system_admin'])\n    if (!hasPermission) {\n      throw new AuthorizationError('Insufficient permissions to create audit entries')\n    }\n\n    const auditId = await createAuditEntry({\n      eventType,\n      eventCategory,\n      userId,\n      userType,\n      entityType,\n      entityId,\n      action,\n      oldValues,\n      newValues,\n      complianceFrameworks,\n      riskLevel,\n      metadata\n    })\n\n    logger.info('Audit entry created successfully', {\n      auditId,\n      eventType,\n      userId,\n      entityType,\n      action\n    })\n\n    return NextResponse.json({\n      success: true,\n      audit_id: auditId,\n      created_at: new Date().toISOString()\n    })\n\n  } catch (error) {\n    if (error instanceof AuthorizationError || error instanceof ValidationError) {\n      logger.error('Audit entry creation error', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    logger.error('Unexpected audit entry creation error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error creating audit entry' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Create an audit trail entry\n */\nasync function createAuditEntry(params: {\n  eventType: string\n  eventCategory: string\n  userId: string\n  userType: 'client' | 'accountant'\n  entityType: string\n  entityId: string | null\n  action: string\n  oldValues?: any\n  newValues?: any\n  complianceFrameworks?: string[]\n  riskLevel?: string\n  metadata?: any\n}): Promise<string> {\n  const {\n    eventType,\n    eventCategory,\n    userId,\n    userType,\n    entityType,\n    entityId,\n    action,\n    oldValues,\n    newValues,\n    complianceFrameworks,\n    riskLevel = 'low',\n    metadata = {}\n  } = params\n\n  // Get previous hash for chain integrity\n  const { data: lastEntry } = await supabase\n    .from('audit_trail')\n    .select('data_hash')\n    .order('created_at', { ascending: false })\n    .limit(1)\n    .single()\n\n  const previousHash = lastEntry?.data_hash || ''\n\n  // Calculate hash for current entry\n  const dataToHash = [\n    eventType,\n    entityType,\n    entityId || '',\n    action,\n    JSON.stringify(oldValues || {}),\n    JSON.stringify(newValues || {}),\n    previousHash,\n    Date.now().toString()\n  ].join('|')\n\n  const dataHash = await generateHash(dataToHash)\n\n  // Determine change summary\n  const changeSummary = generateChangeSummary(action, entityType, oldValues, newValues)\n\n  // Insert audit entry\n  const { data, error } = await supabase\n    .from('audit_trail')\n    .insert({\n      event_type: eventType,\n      event_category: eventCategory,\n      user_id: userId,\n      user_type: userType,\n      entity_type: entityType,\n      entity_id: entityId,\n      action_performed: action,\n      old_values: oldValues,\n      new_values: newValues,\n      change_summary: changeSummary,\n      compliance_framework: complianceFrameworks,\n      risk_level: riskLevel,\n      data_hash: dataHash,\n      previous_hash: previousHash,\n      metadata\n    })\n    .select('id')\n    .single()\n\n  if (error) {\n    throw new DatabaseError('Failed to create audit entry', {\n      dbError: error.message,\n      eventType,\n      entityType,\n      action\n    })\n  }\n\n  return data.id\n}\n\n/**\n * Get audit summary statistics\n */\nasync function getAuditSummaryStats(\n  startDate?: string,\n  endDate?: string,\n  eventType?: string,\n  entityType?: string\n) {\n  let query = supabase\n    .from('audit_trail')\n    .select('event_type, risk_level, approval_status')\n\n  if (startDate) query = query.gte('event_timestamp', startDate)\n  if (endDate) query = query.lte('event_timestamp', endDate)\n  if (eventType) query = query.eq('event_type', eventType)\n  if (entityType) query = query.eq('entity_type', entityType)\n\n  const { data: entries, error } = await query\n\n  if (error) {\n    logger.warn('Failed to get audit summary stats', { error: error.message })\n    return {\n      total_entries: 0,\n      high_risk_entries: 0,\n      pending_approvals: 0,\n      event_type_breakdown: {},\n      risk_level_breakdown: {}\n    }\n  }\n\n  const totalEntries = entries?.length || 0\n  const highRiskEntries = entries?.filter(e => ['high', 'critical'].includes(e.risk_level)).length || 0\n  const pendingApprovals = entries?.filter(e => e.approval_status === 'pending').length || 0\n\n  const eventTypeBreakdown = entries?.reduce((acc: any, entry) => {\n    acc[entry.event_type] = (acc[entry.event_type] || 0) + 1\n    return acc\n  }, {}) || {}\n\n  const riskLevelBreakdown = entries?.reduce((acc: any, entry) => {\n    acc[entry.risk_level] = (acc[entry.risk_level] || 0) + 1\n    return acc\n  }, {}) || {}\n\n  return {\n    total_entries: totalEntries,\n    high_risk_entries: highRiskEntries,\n    pending_approvals: pendingApprovals,\n    event_type_breakdown: eventTypeBreakdown,\n    risk_level_breakdown: riskLevelBreakdown\n  }\n}\n\n/**\n * Generate hash for audit entry\n */\nasync function generateHash(data: string): Promise<string> {\n  const encoder = new TextEncoder()\n  const dataBuffer = encoder.encode(data)\n  const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer)\n  const hashArray = Array.from(new Uint8Array(hashBuffer))\n  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n}\n\n/**\n * Generate human-readable change summary\n */\nfunction generateChangeSummary(\n  action: string,\n  entityType: string,\n  oldValues?: any,\n  newValues?: any\n): string {\n  switch (action) {\n    case 'create':\n      return `Created new ${entityType}`\n    case 'update':\n      if (oldValues && newValues) {\n        const changes = Object.keys(newValues).filter(\n          key => JSON.stringify(oldValues[key]) !== JSON.stringify(newValues[key])\n        )\n        return `Updated ${entityType}: ${changes.join(', ')}`\n      }\n      return `Updated ${entityType}`\n    case 'delete':\n      return `Deleted ${entityType}`\n    case 'export':\n      return `Exported ${entityType} data`\n    case 'approve':\n      return `Approved ${entityType}`\n    case 'reject':\n      return `Rejected ${entityType}`\n    default:\n      return `Performed ${action} on ${entityType}`\n  }\n}\n"