import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { logger } from '@/lib/logger'\nimport { ValidationError, DatabaseError } from '@/lib/errors'\n\n// GET endpoint for retrieving messages\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const conversationId = searchParams.get('conversationId')\n    const userId = searchParams.get('userId')\n    const userType = searchParams.get('userType') as 'client' | 'accountant'\n    const limit = parseInt(searchParams.get('limit') || '50')\n    const offset = parseInt(searchParams.get('offset') || '0')\n\n    if (!conversationId && !userId) {\n      const error = new ValidationError('Either conversationId or userId is required')\n      logger.error('Messages API validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    if (conversationId) {\n      // Get messages for a specific conversation\n      return await getConversationMessages(conversationId, limit, offset)\n    } else {\n      // Get conversations for a user\n      return await getUserConversations(userId!, userType!, limit, offset)\n    }\n\n  } catch (error) {\n    logger.error('Messages API service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error fetching messages' },\n      { status: 500 }\n    )\n  }\n}\n\n// POST endpoint for sending messages\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const {\n      conversationId,\n      fromUserId,\n      fromUserType,\n      toUserId,\n      toUserType,\n      content,\n      messageType = 'text',\n      priority = 'normal',\n      metadata = {}\n    } = body\n\n    // Validate required fields\n    if (!conversationId || !fromUserId || !fromUserType || !toUserId || !toUserType || !content) {\n      const error = new ValidationError('Missing required fields for sending message')\n      logger.error('Send message validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Verify conversation exists and user has access\n    const { data: conversation, error: conversationError } = await supabase\n      .from('conversations')\n      .select('id, client_id, accountant_id')\n      .eq('id', conversationId)\n      .single()\n\n    if (conversationError || !conversation) {\n      return NextResponse.json(\n        { error: 'Conversation not found' },\n        { status: 404 }\n      )\n    }\n\n    // Verify user has access to this conversation\n    const hasAccess = (\n      (fromUserType === 'client' && conversation.client_id === fromUserId) ||\n      (fromUserType === 'accountant' && conversation.accountant_id === fromUserId)\n    )\n\n    if (!hasAccess) {\n      return NextResponse.json(\n        { error: 'Unauthorized access to conversation' },\n        { status: 403 }\n      )\n    }\n\n    // Send the message using the database function\n    const { data: messageId, error: sendError } = await supabase\n      .rpc('send_message', {\n        p_conversation_id: conversationId,\n        p_from_user_id: fromUserId,\n        p_from_user_type: fromUserType,\n        p_to_user_id: toUserId,\n        p_to_user_type: toUserType,\n        p_content: content,\n        p_message_type: messageType,\n        p_priority: priority,\n        p_metadata: metadata\n      })\n\n    if (sendError) {\n      const error = new DatabaseError('Failed to send message', {\n        dbError: sendError.message\n      })\n      logger.error('Database error sending message', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Get the sent message details\n    const { data: sentMessage, error: messageError } = await supabase\n      .from('messages')\n      .select(`\n        id,\n        content,\n        sent_at,\n        message_type,\n        priority,\n        metadata\n      `)\n      .eq('id', messageId)\n      .single()\n\n    if (messageError) {\n      logger.error('Error fetching sent message details', messageError)\n    }\n\n    logger.info('Message sent successfully', {\n      messageId,\n      conversationId,\n      fromUserId,\n      toUserId\n    })\n\n    return NextResponse.json({\n      success: true,\n      message: sentMessage || { id: messageId },\n      messageId\n    })\n\n  } catch (error) {\n    logger.error('Send message service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error sending message' },\n      { status: 500 }\n    )\n  }\n}\n\n// PUT endpoint for marking messages as read\nexport async function PUT(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { action, userId, userType, conversationId, messageIds } = body\n\n    if (action !== 'mark_as_read') {\n      return NextResponse.json(\n        { error: 'Unknown action' },\n        { status: 400 }\n      )\n    }\n\n    if (!userId || !userType) {\n      const error = new ValidationError('Missing userId or userType')\n      logger.error('Mark as read validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Mark messages as read using the database function\n    const { data: updatedCount, error: markError } = await supabase\n      .rpc('mark_messages_as_read', {\n        p_user_id: userId,\n        p_user_type: userType,\n        p_conversation_id: conversationId || null,\n        p_message_ids: messageIds || null\n      })\n\n    if (markError) {\n      const error = new DatabaseError('Failed to mark messages as read', {\n        dbError: markError.message\n      })\n      logger.error('Database error marking messages as read', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    logger.info('Messages marked as read', {\n      userId,\n      userType,\n      conversationId,\n      messageIds,\n      updatedCount\n    })\n\n    return NextResponse.json({\n      success: true,\n      updatedCount\n    })\n\n  } catch (error) {\n    logger.error('Mark as read service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error marking messages as read' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Get messages for a specific conversation\n */\nasync function getConversationMessages(\n  conversationId: string,\n  limit: number,\n  offset: number\n) {\n  const { data: messages, error: messagesError } = await supabase\n    .from('messages')\n    .select(`\n      id,\n      from_user_id,\n      from_user_type,\n      to_user_id,\n      to_user_type,\n      content,\n      message_type,\n      priority,\n      sent_at,\n      read_at,\n      is_read,\n      metadata,\n      message_attachments (\n        id,\n        file_name,\n        file_path,\n        file_size,\n        mime_type,\n        metadata\n      )\n    `)\n    .eq('conversation_id', conversationId)\n    .eq('is_deleted', false)\n    .order('sent_at', { ascending: true })\n    .range(offset, offset + limit - 1)\n\n  if (messagesError) {\n    const error = new DatabaseError('Failed to fetch conversation messages', {\n      conversationId,\n      dbError: messagesError.message\n    })\n    logger.error('Database error fetching messages', error)\n    return NextResponse.json(\n      { error: error.message },\n      { status: error.statusCode }\n    )\n  }\n\n  // Format messages for frontend\n  const formattedMessages = messages?.map(message => ({\n    id: message.id,\n    from: message.from_user_type,\n    fromName: message.from_user_type === 'client' ? 'You' : 'Accountant', // TODO: Get actual names\n    message: message.content,\n    timestamp: message.sent_at,\n    read: message.is_read,\n    type: message.message_type,\n    attachments: message.message_attachments?.map((attachment: any) => ({\n      id: attachment.id,\n      name: attachment.file_name,\n      url: attachment.file_path, // TODO: Generate signed URL\n      type: attachment.mime_type,\n      size: attachment.file_size\n    })) || [],\n    metadata: message.metadata\n  })) || []\n\n  return NextResponse.json({\n    success: true,\n    messages: formattedMessages,\n    total: formattedMessages.length,\n    hasMore: formattedMessages.length === limit\n  })\n}\n\n/**\n * Get conversations for a specific user\n */\nasync function getUserConversations(\n  userId: string,\n  userType: 'client' | 'accountant',\n  limit: number,\n  offset: number\n) {\n  let query = supabase\n    .from('conversations')\n    .select(`\n      id,\n      client_id,\n      accountant_id,\n      created_at,\n      updated_at,\n      last_message_at,\n      last_message_preview,\n      is_archived,\n      client:clients!inner(\n        id,\n        name,\n        email\n      ),\n      accountant:accountants!inner(\n        id,\n        name,\n        email\n      )\n    `)\n    .eq('is_archived', false)\n    .order('last_message_at', { ascending: false })\n    .range(offset, offset + limit - 1)\n\n  // Filter by user type\n  if (userType === 'client') {\n    query = query.eq('client_id', userId)\n  } else {\n    query = query.eq('accountant_id', userId)\n  }\n\n  const { data: conversations, error: conversationsError } = await query\n\n  if (conversationsError) {\n    const error = new DatabaseError('Failed to fetch user conversations', {\n      userId,\n      userType,\n      dbError: conversationsError.message\n    })\n    logger.error('Database error fetching conversations', error)\n    return NextResponse.json(\n      { error: error.message },\n      { status: error.statusCode }\n    )\n  }\n\n  // Get unread message counts for each conversation\n  const conversationIds = conversations?.map(c => c.id) || []\n  const { data: unreadCounts, error: unreadError } = await supabase\n    .from('messages')\n    .select('conversation_id')\n    .in('conversation_id', conversationIds)\n    .eq('to_user_id', userId)\n    .eq('to_user_type', userType)\n    .eq('is_read', false)\n    .eq('is_deleted', false)\n\n  if (unreadError) {\n    logger.error('Error fetching unread counts', unreadError)\n  }\n\n  // Count unread messages per conversation\n  const unreadCountMap = (unreadCounts || []).reduce((acc: Record<string, number>, msg: any) => {\n    acc[msg.conversation_id] = (acc[msg.conversation_id] || 0) + 1\n    return acc\n  }, {})\n\n  // Format conversations for frontend\n  const formattedConversations = conversations?.map(conversation => {\n    const otherParticipant = userType === 'client' \n      ? conversation.accountant \n      : conversation.client\n\n    return {\n      id: conversation.id,\n      participant: {\n        id: otherParticipant.id,\n        name: otherParticipant.name,\n        email: otherParticipant.email,\n        role: userType === 'client' ? 'accountant' : 'client',\n        status: 'offline' // TODO: Implement real-time presence\n      },\n      lastMessage: {\n        preview: conversation.last_message_preview,\n        timestamp: conversation.last_message_at\n      },\n      unreadCount: unreadCountMap[conversation.id] || 0,\n      createdAt: conversation.created_at,\n      updatedAt: conversation.updated_at\n    }\n  }) || []\n\n  return NextResponse.json({\n    success: true,\n    conversations: formattedConversations,\n    total: formattedConversations.length,\n    hasMore: formattedConversations.length === limit\n  })\n}\n"