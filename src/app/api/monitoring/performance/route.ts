import { NextRequest, NextResponse } from 'next/server'\nimport { logger } from '@/lib/logger'\nimport { ValidationError, DatabaseError } from '@/lib/errors'\nimport { supabase } from '@/lib/supabase'\n\n// Performance monitoring endpoint\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const timeRange = searchParams.get('timeRange') || '1h'\n    const metric = searchParams.get('metric') || 'all'\n    const endpoint = searchParams.get('endpoint')\n\n    const performanceData = await getPerformanceMetrics(timeRange, metric, endpoint)\n\n    return NextResponse.json({\n      success: true,\n      data: performanceData,\n      metadata: {\n        timeRange,\n        metric,\n        endpoint,\n        generatedAt: new Date().toISOString()\n      }\n    })\n\n  } catch (error) {\n    logger.error('Performance monitoring API error', error as Error)\n    return NextResponse.json(\n      { error: 'Failed to fetch performance metrics' },\n      { status: 500 }\n    )\n  }\n}\n\n// Record performance metrics\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const {\n      endpoint,\n      method,\n      responseTime,\n      statusCode,\n      userAgent,\n      userId,\n      timestamp\n    } = body\n\n    // Validate required fields\n    if (!endpoint || !method || responseTime === undefined || !statusCode) {\n      throw new ValidationError('Missing required performance metric fields')\n    }\n\n    // Record performance metric\n    const metricId = await recordPerformanceMetric({\n      endpoint,\n      method,\n      responseTime,\n      statusCode,\n      userAgent,\n      userId,\n      timestamp: timestamp || new Date().toISOString()\n    })\n\n    // Check for performance alerts\n    await checkPerformanceAlerts({\n      endpoint,\n      responseTime,\n      statusCode\n    })\n\n    logger.info('Performance metric recorded', {\n      metricId,\n      endpoint,\n      responseTime,\n      statusCode\n    })\n\n    return NextResponse.json({\n      success: true,\n      metricId,\n      recorded_at: new Date().toISOString()\n    })\n\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      logger.error('Performance metric validation error', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    logger.error('Performance metric recording error', error as Error)\n    return NextResponse.json(\n      { error: 'Failed to record performance metric' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Get performance metrics from database\n */\nasync function getPerformanceMetrics(\n  timeRange: string,\n  metric: string,\n  endpoint?: string | null\n) {\n  const timeRangeMap: Record<string, string> = {\n    '1h': '1 hour',\n    '24h': '24 hours',\n    '7d': '7 days',\n    '30d': '30 days'\n  }\n\n  const interval = timeRangeMap[timeRange] || '1 hour'\n  const startTime = new Date(Date.now() - getTimeRangeMs(timeRange))\n\n  let query = supabase\n    .from('performance_metrics')\n    .select('*')\n    .gte('timestamp', startTime.toISOString())\n    .order('timestamp', { ascending: false })\n\n  if (endpoint) {\n    query = query.eq('endpoint', endpoint)\n  }\n\n  const { data: metrics, error } = await query\n\n  if (error) {\n    throw new DatabaseError('Failed to fetch performance metrics', {\n      dbError: error.message,\n      timeRange,\n      metric,\n      endpoint\n    })\n  }\n\n  // Calculate aggregated metrics\n  const aggregatedMetrics = calculateAggregatedMetrics(metrics || [])\n  \n  // Get endpoint breakdown\n  const endpointBreakdown = getEndpointBreakdown(metrics || [])\n  \n  // Get performance trends\n  const trends = calculatePerformanceTrends(metrics || [], timeRange)\n  \n  // Get current system status\n  const systemStatus = await getCurrentSystemStatus()\n\n  return {\n    summary: aggregatedMetrics,\n    endpoints: endpointBreakdown,\n    trends,\n    systemStatus,\n    rawMetrics: metric === 'raw' ? metrics : undefined\n  }\n}\n\n/**\n * Record a performance metric\n */\nasync function recordPerformanceMetric(params: {\n  endpoint: string\n  method: string\n  responseTime: number\n  statusCode: number\n  userAgent?: string\n  userId?: string\n  timestamp: string\n}): Promise<string> {\n  const {\n    endpoint,\n    method,\n    responseTime,\n    statusCode,\n    userAgent,\n    userId,\n    timestamp\n  } = params\n\n  // Determine performance category\n  const category = categorizePerformance(responseTime)\n  \n  // Calculate performance score\n  const score = calculatePerformanceScore(responseTime, statusCode)\n\n  const { data, error } = await supabase\n    .from('performance_metrics')\n    .insert({\n      endpoint,\n      method,\n      response_time_ms: responseTime,\n      status_code: statusCode,\n      performance_category: category,\n      performance_score: score,\n      user_agent: userAgent,\n      user_id: userId,\n      timestamp,\n      metadata: {\n        recorded_by: 'api',\n        version: process.env.APP_VERSION || '1.0.0'\n      }\n    })\n    .select('id')\n    .single()\n\n  if (error) {\n    throw new DatabaseError('Failed to record performance metric', {\n      dbError: error.message,\n      endpoint,\n      responseTime,\n      statusCode\n    })\n  }\n\n  return data.id\n}\n\n/**\n * Check for performance alerts\n */\nasync function checkPerformanceAlerts(params: {\n  endpoint: string\n  responseTime: number\n  statusCode: number\n}) {\n  const { endpoint, responseTime, statusCode } = params\n  const alerts = []\n\n  // Slow response alert\n  if (responseTime > 2000) {\n    alerts.push({\n      type: 'slow_response',\n      severity: responseTime > 5000 ? 'critical' : 'warning',\n      message: `Slow response detected: ${endpoint} took ${responseTime}ms`,\n      threshold: 2000,\n      actual: responseTime\n    })\n  }\n\n  // Error status alert\n  if (statusCode >= 500) {\n    alerts.push({\n      type: 'server_error',\n      severity: 'critical',\n      message: `Server error detected: ${endpoint} returned ${statusCode}`,\n      statusCode\n    })\n  } else if (statusCode >= 400) {\n    alerts.push({\n      type: 'client_error',\n      severity: 'warning',\n      message: `Client error detected: ${endpoint} returned ${statusCode}`,\n      statusCode\n    })\n  }\n\n  // Send alerts if any\n  for (const alert of alerts) {\n    await sendPerformanceAlert(alert)\n  }\n}\n\n/**\n * Send performance alert\n */\nasync function sendPerformanceAlert(alert: any) {\n  try {\n    // Record alert in database\n    await supabase\n      .from('performance_alerts')\n      .insert({\n        alert_type: alert.type,\n        severity: alert.severity,\n        message: alert.message,\n        metadata: alert,\n        created_at: new Date().toISOString()\n      })\n\n    // Send to external monitoring service if configured\n    if (process.env.MONITORING_WEBHOOK_URL) {\n      await fetch(process.env.MONITORING_WEBHOOK_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${process.env.MONITORING_API_KEY}`\n        },\n        body: JSON.stringify({\n          alert,\n          timestamp: new Date().toISOString(),\n          source: 'booksflowai-api'\n        })\n      })\n    }\n\n    logger.warn('Performance alert sent', alert)\n\n  } catch (error) {\n    logger.error('Failed to send performance alert', error as Error)\n  }\n}\n\n/**\n * Calculate aggregated metrics\n */\nfunction calculateAggregatedMetrics(metrics: any[]) {\n  if (metrics.length === 0) {\n    return {\n      totalRequests: 0,\n      averageResponseTime: 0,\n      p95ResponseTime: 0,\n      p99ResponseTime: 0,\n      errorRate: 0,\n      successRate: 100\n    }\n  }\n\n  const responseTimes = metrics.map(m => m.response_time_ms).sort((a, b) => a - b)\n  const errorCount = metrics.filter(m => m.status_code >= 400).length\n  \n  const p95Index = Math.floor(responseTimes.length * 0.95)\n  const p99Index = Math.floor(responseTimes.length * 0.99)\n\n  return {\n    totalRequests: metrics.length,\n    averageResponseTime: Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length),\n    p95ResponseTime: responseTimes[p95Index] || 0,\n    p99ResponseTime: responseTimes[p99Index] || 0,\n    errorRate: Math.round((errorCount / metrics.length) * 100 * 100) / 100,\n    successRate: Math.round(((metrics.length - errorCount) / metrics.length) * 100 * 100) / 100\n  }\n}\n\n/**\n * Get endpoint breakdown\n */\nfunction getEndpointBreakdown(metrics: any[]) {\n  const endpointMap = new Map()\n\n  metrics.forEach(metric => {\n    const key = `${metric.method} ${metric.endpoint}`\n    if (!endpointMap.has(key)) {\n      endpointMap.set(key, {\n        endpoint: metric.endpoint,\n        method: metric.method,\n        requests: 0,\n        totalResponseTime: 0,\n        errors: 0\n      })\n    }\n\n    const data = endpointMap.get(key)\n    data.requests++\n    data.totalResponseTime += metric.response_time_ms\n    if (metric.status_code >= 400) {\n      data.errors++\n    }\n  })\n\n  return Array.from(endpointMap.values()).map(data => ({\n    ...data,\n    averageResponseTime: Math.round(data.totalResponseTime / data.requests),\n    errorRate: Math.round((data.errors / data.requests) * 100 * 100) / 100\n  })).sort((a, b) => b.requests - a.requests)\n}\n\n/**\n * Calculate performance trends\n */\nfunction calculatePerformanceTrends(metrics: any[], timeRange: string) {\n  const bucketSize = getBucketSize(timeRange)\n  const buckets = new Map()\n\n  metrics.forEach(metric => {\n    const bucketKey = Math.floor(new Date(metric.timestamp).getTime() / bucketSize) * bucketSize\n    \n    if (!buckets.has(bucketKey)) {\n      buckets.set(bucketKey, {\n        timestamp: new Date(bucketKey).toISOString(),\n        requests: 0,\n        totalResponseTime: 0,\n        errors: 0\n      })\n    }\n\n    const bucket = buckets.get(bucketKey)\n    bucket.requests++\n    bucket.totalResponseTime += metric.response_time_ms\n    if (metric.status_code >= 400) {\n      bucket.errors++\n    }\n  })\n\n  return Array.from(buckets.values())\n    .map(bucket => ({\n      ...bucket,\n      averageResponseTime: bucket.requests > 0 ? Math.round(bucket.totalResponseTime / bucket.requests) : 0,\n      errorRate: bucket.requests > 0 ? Math.round((bucket.errors / bucket.requests) * 100 * 100) / 100 : 0\n    }))\n    .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())\n}\n\n/**\n * Get current system status\n */\nasync function getCurrentSystemStatus() {\n  // Get recent metrics (last 5 minutes)\n  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000)\n  \n  const { data: recentMetrics } = await supabase\n    .from('performance_metrics')\n    .select('response_time_ms, status_code')\n    .gte('timestamp', fiveMinutesAgo.toISOString())\n\n  if (!recentMetrics || recentMetrics.length === 0) {\n    return {\n      status: 'unknown',\n      message: 'No recent metrics available'\n    }\n  }\n\n  const avgResponseTime = recentMetrics.reduce((sum, m) => sum + m.response_time_ms, 0) / recentMetrics.length\n  const errorRate = recentMetrics.filter(m => m.status_code >= 400).length / recentMetrics.length * 100\n\n  let status = 'healthy'\n  let message = 'All systems operational'\n\n  if (avgResponseTime > 2000 || errorRate > 5) {\n    status = 'degraded'\n    message = 'Performance degradation detected'\n  }\n\n  if (avgResponseTime > 5000 || errorRate > 10) {\n    status = 'unhealthy'\n    message = 'System performance issues detected'\n  }\n\n  return {\n    status,\n    message,\n    metrics: {\n      averageResponseTime: Math.round(avgResponseTime),\n      errorRate: Math.round(errorRate * 100) / 100,\n      totalRequests: recentMetrics.length\n    }\n  }\n}\n\n/**\n * Helper functions\n */\nfunction getTimeRangeMs(timeRange: string): number {\n  const ranges: Record<string, number> = {\n    '1h': 60 * 60 * 1000,\n    '24h': 24 * 60 * 60 * 1000,\n    '7d': 7 * 24 * 60 * 60 * 1000,\n    '30d': 30 * 24 * 60 * 60 * 1000\n  }\n  return ranges[timeRange] || ranges['1h']\n}\n\nfunction getBucketSize(timeRange: string): number {\n  const buckets: Record<string, number> = {\n    '1h': 5 * 60 * 1000,      // 5 minutes\n    '24h': 60 * 60 * 1000,    // 1 hour\n    '7d': 6 * 60 * 60 * 1000, // 6 hours\n    '30d': 24 * 60 * 60 * 1000 // 1 day\n  }\n  return buckets[timeRange] || buckets['1h']\n}\n\nfunction categorizePerformance(responseTime: number): string {\n  if (responseTime < 200) return 'excellent'\n  if (responseTime < 500) return 'good'\n  if (responseTime < 1000) return 'acceptable'\n  if (responseTime < 2000) return 'slow'\n  return 'critical'\n}\n\nfunction calculatePerformanceScore(responseTime: number, statusCode: number): number {\n  let score = 100\n  \n  // Deduct points for slow response\n  if (responseTime > 200) score -= Math.min(50, (responseTime - 200) / 100)\n  \n  // Deduct points for errors\n  if (statusCode >= 400) score -= 30\n  if (statusCode >= 500) score -= 50\n  \n  return Math.max(0, Math.round(score))\n}\n"