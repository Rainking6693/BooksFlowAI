import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { sendMissingReceiptReminder, sendReportReadyNotification } from '@/lib/integrations/email-service'\nimport { logger } from '@/lib/logger'\nimport { DatabaseError } from '@/lib/errors'\n\n// This endpoint handles automated notification scheduling\n// In production, this would be called by a cron job or scheduled task\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { action, accountantId } = body\n\n    if (!action) {\n      return NextResponse.json(\n        { error: 'Action is required' },\n        { status: 400 }\n      )\n    }\n\n    let results: any = {}\n\n    switch (action) {\n      case 'send_missing_receipt_reminders':\n        results = await processMissingReceiptReminders(accountantId)\n        break\n      \n      case 'send_report_notifications':\n        results = await processReportNotifications(accountantId)\n        break\n      \n      case 'send_weekly_summary':\n        results = await processWeeklySummary(accountantId)\n        break\n      \n      case 'cleanup_old_notifications':\n        results = await cleanupOldNotifications()\n        break\n      \n      default:\n        return NextResponse.json(\n          { error: 'Unknown action' },\n          { status: 400 }\n        )\n    }\n\n    return NextResponse.json({\n      success: true,\n      action,\n      results\n    })\n\n  } catch (error) {\n    logger.error('Notification scheduler error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error in notification scheduler' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Process missing receipt reminders\n */\nasync function processMissingReceiptReminders(accountantId?: string): Promise<{\n  processed: number\n  sent: number\n  failed: number\n  details: Array<{ clientId: string; status: 'sent' | 'failed'; error?: string }>\n}> {\n  try {\n    logger.info('Processing missing receipt reminders', { accountantId })\n\n    // Get clients with missing receipts\n    let query = supabase\n      .from('clients')\n      .select(`\n        id,\n        name,\n        email,\n        accountant:accountants!inner(\n          id,\n          name,\n          email\n        )\n      `)\n\n    if (accountantId) {\n      query = query.eq('accountant_id', accountantId)\n    }\n\n    const { data: clients, error: clientsError } = await query\n\n    if (clientsError) {\n      throw new DatabaseError('Failed to fetch clients', { dbError: clientsError.message })\n    }\n\n    if (!clients || clients.length === 0) {\n      return { processed: 0, sent: 0, failed: 0, details: [] }\n    }\n\n    const results = {\n      processed: 0,\n      sent: 0,\n      failed: 0,\n      details: [] as Array<{ clientId: string; status: 'sent' | 'failed'; error?: string }>\n    }\n\n    for (const client of clients) {\n      try {\n        results.processed++\n\n        // Get missing receipts for this client\n        const missingReceipts = await getMissingReceiptsForClient(client.id, client.accountant.id)\n\n        if (missingReceipts.length === 0) {\n          continue // No missing receipts, skip\n        }\n\n        // Check if we've sent a reminder recently (within last 3 days)\n        const { data: recentReminder, error: reminderError } = await supabase\n          .from('email_logs')\n          .select('id')\n          .eq('recipient_email', client.email)\n          .eq('email_type', 'missing_receipt_reminder')\n          .gte('sent_at', new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString())\n          .limit(1)\n\n        if (reminderError) {\n          logger.error('Error checking recent reminders', reminderError)\n        }\n\n        if (recentReminder && recentReminder.length > 0) {\n          continue // Already sent reminder recently, skip\n        }\n\n        // Calculate total amount\n        const totalAmount = missingReceipts.reduce((sum, receipt) => sum + receipt.amount, 0)\n\n        // Send reminder email\n        const emailResult = await sendMissingReceiptReminder({\n          clientName: client.name,\n          clientEmail: client.email,\n          accountantName: client.accountant.name,\n          missingReceipts,\n          totalAmount,\n          portalUrl: `${process.env.NEXT_PUBLIC_APP_URL}/client-portal`\n        })\n\n        if (emailResult.success) {\n          results.sent++\n          results.details.push({ clientId: client.id, status: 'sent' })\n\n          // Log the email\n          await supabase.from('email_logs').insert({\n            recipient_email: client.email,\n            recipient_name: client.name,\n            email_type: 'missing_receipt_reminder',\n            subject: `Missing Receipts Reminder - ${missingReceipts.length} receipts needed`,\n            sent_at: new Date().toISOString(),\n            message_id: emailResult.messageId,\n            status: 'sent',\n            metadata: {\n              missingReceiptsCount: missingReceipts.length,\n              totalAmount,\n              accountantId: client.accountant.id\n            }\n          })\n\n          // Create notification record\n          await supabase.from('notifications').insert({\n            user_id: client.id,\n            type: 'missing_receipt_reminder',\n            title: 'Missing Receipts Reminder Sent',\n            message: `Reminder sent for ${missingReceipts.length} missing receipts`,\n            read: false,\n            created_at: new Date().toISOString(),\n            metadata: {\n              missingReceiptsCount: missingReceipts.length,\n              totalAmount\n            }\n          })\n\n        } else {\n          results.failed++\n          results.details.push({ \n            clientId: client.id, \n            status: 'failed', \n            error: emailResult.error \n          })\n\n          // Log the failure\n          await supabase.from('email_logs').insert({\n            recipient_email: client.email,\n            recipient_name: client.name,\n            email_type: 'missing_receipt_reminder',\n            subject: `Missing Receipts Reminder - ${missingReceipts.length} receipts needed`,\n            sent_at: new Date().toISOString(),\n            status: 'failed',\n            error_message: emailResult.error,\n            metadata: {\n              missingReceiptsCount: missingReceipts.length,\n              totalAmount,\n              accountantId: client.accountant.id\n            }\n          })\n        }\n\n      } catch (error) {\n        results.failed++\n        results.details.push({ \n          clientId: client.id, \n          status: 'failed', \n          error: error instanceof Error ? error.message : 'Unknown error'\n        })\n        \n        logger.error('Error processing reminder for client', error as Error, {\n          clientId: client.id,\n          clientEmail: client.email\n        })\n      }\n    }\n\n    logger.info('Missing receipt reminders processing complete', results)\n    return results\n\n  } catch (error) {\n    logger.error('Error processing missing receipt reminders', error as Error)\n    throw error\n  }\n}\n\n/**\n * Get missing receipts for a specific client\n */\nasync function getMissingReceiptsForClient(\n  clientId: string, \n  accountantId: string\n): Promise<Array<{\n  id: string\n  description: string\n  amount: number\n  date: string\n  daysOverdue: number\n}>> {\n  // Get transactions without receipts for this client's accountant\n  const { data: transactions, error } = await supabase\n    .from('transactions')\n    .select('id, description, amount, transaction_date')\n    .eq('accountant_id', accountantId)\n    .is('receipt_id', null)\n    .gte('transaction_date', new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]) // Last 90 days\n    .lt('transaction_date', new Date().toISOString().split('T')[0]) // Before today\n    .order('transaction_date', { ascending: false })\n    .limit(50)\n\n  if (error) {\n    logger.error('Error fetching missing receipts', error)\n    return []\n  }\n\n  if (!transactions || transactions.length === 0) {\n    return []\n  }\n\n  return transactions.map(transaction => {\n    const daysOverdue = Math.floor(\n      (Date.now() - new Date(transaction.transaction_date).getTime()) / (1000 * 60 * 60 * 24)\n    )\n\n    return {\n      id: transaction.id,\n      description: transaction.description,\n      amount: Math.abs(transaction.amount),\n      date: transaction.transaction_date,\n      daysOverdue\n    }\n  })\n}\n\n/**\n * Process report ready notifications\n */\nasync function processReportNotifications(accountantId?: string): Promise<{\n  processed: number\n  sent: number\n  failed: number\n}> {\n  try {\n    logger.info('Processing report notifications', { accountantId })\n\n    // Get reports that are ready but haven't been notified\n    let query = supabase\n      .from('reports')\n      .select(`\n        id,\n        title,\n        period_start,\n        period_end,\n        file_url,\n        client:clients!inner(\n          id,\n          name,\n          email,\n          accountant:accountants!inner(\n            id,\n            name\n          )\n        )\n      `)\n      .eq('status', 'completed')\n      .eq('notification_sent', false)\n      .not('file_url', 'is', null)\n\n    if (accountantId) {\n      query = query.eq('client.accountant_id', accountantId)\n    }\n\n    const { data: reports, error: reportsError } = await query\n\n    if (reportsError) {\n      throw new DatabaseError('Failed to fetch reports', { dbError: reportsError.message })\n    }\n\n    if (!reports || reports.length === 0) {\n      return { processed: 0, sent: 0, failed: 0 }\n    }\n\n    const results = { processed: 0, sent: 0, failed: 0 }\n\n    for (const report of reports) {\n      try {\n        results.processed++\n\n        const emailResult = await sendReportReadyNotification({\n          clientName: report.client.name,\n          clientEmail: report.client.email,\n          reportTitle: report.title,\n          reportPeriod: `${new Date(report.period_start).toLocaleDateString()} - ${new Date(report.period_end).toLocaleDateString()}`,\n          downloadUrl: report.file_url,\n          accountantName: report.client.accountant.name\n        })\n\n        if (emailResult.success) {\n          results.sent++\n\n          // Mark report as notified\n          await supabase\n            .from('reports')\n            .update({ \n              notification_sent: true, \n              notification_sent_at: new Date().toISOString() \n            })\n            .eq('id', report.id)\n\n          // Log the email\n          await supabase.from('email_logs').insert({\n            recipient_email: report.client.email,\n            recipient_name: report.client.name,\n            email_type: 'report_ready',\n            subject: `Your ${report.title} is Ready`,\n            sent_at: new Date().toISOString(),\n            message_id: emailResult.messageId,\n            status: 'sent',\n            metadata: {\n              reportId: report.id,\n              reportTitle: report.title\n            }\n          })\n\n        } else {\n          results.failed++\n          logger.error('Failed to send report notification', new Error(emailResult.error), {\n            reportId: report.id,\n            clientEmail: report.client.email\n          })\n        }\n\n      } catch (error) {\n        results.failed++\n        logger.error('Error processing report notification', error as Error, {\n          reportId: report.id\n        })\n      }\n    }\n\n    logger.info('Report notifications processing complete', results)\n    return results\n\n  } catch (error) {\n    logger.error('Error processing report notifications', error as Error)\n    throw error\n  }\n}\n\n/**\n * Process weekly summary emails\n */\nasync function processWeeklySummary(accountantId?: string): Promise<{\n  processed: number\n  sent: number\n  failed: number\n}> {\n  // TODO: Implement weekly summary email processing\n  logger.info('Weekly summary processing not yet implemented', { accountantId })\n  return { processed: 0, sent: 0, failed: 0 }\n}\n\n/**\n * Clean up old notification records\n */\nasync function cleanupOldNotifications(): Promise<{\n  deletedNotifications: number\n  deletedEmailLogs: number\n}> {\n  try {\n    logger.info('Cleaning up old notifications')\n\n    const cutoffDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString() // 90 days ago\n\n    // Delete old read notifications\n    const { error: notificationError, count: deletedNotifications } = await supabase\n      .from('notifications')\n      .delete()\n      .eq('read', true)\n      .lt('created_at', cutoffDate)\n\n    if (notificationError) {\n      logger.error('Error deleting old notifications', notificationError)\n    }\n\n    // Delete old email logs (keep for audit purposes, but clean up very old ones)\n    const oldCutoffDate = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString() // 1 year ago\n    \n    const { error: emailLogError, count: deletedEmailLogs } = await supabase\n      .from('email_logs')\n      .delete()\n      .lt('sent_at', oldCutoffDate)\n\n    if (emailLogError) {\n      logger.error('Error deleting old email logs', emailLogError)\n    }\n\n    const results = {\n      deletedNotifications: deletedNotifications || 0,\n      deletedEmailLogs: deletedEmailLogs || 0\n    }\n\n    logger.info('Cleanup complete', results)\n    return results\n\n  } catch (error) {\n    logger.error('Error during cleanup', error as Error)\n    throw error\n  }\n}\n\n// GET endpoint for notification statistics\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const accountantId = searchParams.get('accountantId')\n    const days = parseInt(searchParams.get('days') || '7')\n\n    const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString()\n\n    // Get email statistics\n    let emailQuery = supabase\n      .from('email_logs')\n      .select('email_type, status, sent_at')\n      .gte('sent_at', cutoffDate)\n\n    if (accountantId) {\n      emailQuery = emailQuery.eq('metadata->>accountantId', accountantId)\n    }\n\n    const { data: emailLogs, error: emailError } = await emailQuery\n\n    if (emailError) {\n      throw new DatabaseError('Failed to fetch email statistics', { dbError: emailError.message })\n    }\n\n    // Calculate statistics\n    const stats = {\n      totalEmails: emailLogs?.length || 0,\n      sentEmails: emailLogs?.filter(log => log.status === 'sent').length || 0,\n      failedEmails: emailLogs?.filter(log => log.status === 'failed').length || 0,\n      emailTypes: {} as Record<string, number>,\n      dailyStats: {} as Record<string, { sent: number; failed: number }>\n    }\n\n    // Group by email type\n    emailLogs?.forEach(log => {\n      stats.emailTypes[log.email_type] = (stats.emailTypes[log.email_type] || 0) + 1\n      \n      const day = new Date(log.sent_at).toISOString().split('T')[0]\n      if (!stats.dailyStats[day]) {\n        stats.dailyStats[day] = { sent: 0, failed: 0 }\n      }\n      \n      if (log.status === 'sent') {\n        stats.dailyStats[day].sent++\n      } else {\n        stats.dailyStats[day].failed++\n      }\n    })\n\n    stats.successRate = stats.totalEmails > 0 \n      ? Math.round((stats.sentEmails / stats.totalEmails) * 100) \n      : 0\n\n    return NextResponse.json({\n      success: true,\n      period: `${days} days`,\n      statistics: stats\n    })\n\n  } catch (error) {\n    logger.error('Error fetching notification statistics', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error fetching statistics' },\n      { status: 500 }\n    )\n  }\n}\n"