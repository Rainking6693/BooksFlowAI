import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { findMatchingTransactions } from '@/lib/integrations/mindee-ocr'\nimport { logger } from '@/lib/logger'\nimport { ValidationError, DatabaseError } from '@/lib/errors'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { receiptId, accountantId, transactionId, action } = body\n\n    // Validate required fields\n    if (!receiptId || !accountantId || !action) {\n      const error = new ValidationError('Missing required fields: receiptId, accountantId, action', {\n        receiptId: !!receiptId,\n        accountantId: !!accountantId,\n        action: !!action\n      })\n      logger.error('Receipt matching validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    if (!['link', 'unlink', 'suggest'].includes(action)) {\n      const error = new ValidationError('Action must be \"link\", \"unlink\", or \"suggest\"', {\n        providedAction: action\n      })\n      logger.error('Invalid action provided', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Get receipt data\n    const { data: receipt, error: receiptError } = await supabase\n      .from('receipts')\n      .select(`\n        *,\n        client:clients!inner(accountant_id)\n      `)\n      .eq('id', receiptId)\n      .single()\n\n    if (receiptError || !receipt) {\n      const error = new DatabaseError('Failed to fetch receipt', {\n        receiptId,\n        dbError: receiptError?.message\n      })\n      logger.error('Receipt fetch failed', error)\n      return NextResponse.json(\n        { error: 'Receipt not found' },\n        { status: 404 }\n      )\n    }\n\n    // Verify accountant has access to this receipt\n    if (receipt.client.accountant_id !== accountantId) {\n      return NextResponse.json(\n        { error: 'Unauthorized: Invalid accountant access' },\n        { status: 403 }\n      )\n    }\n\n    if (action === 'suggest') {\n      return await handleSuggestMatches(receipt, accountantId)\n    } else if (action === 'link') {\n      return await handleLinkTransaction(receipt, transactionId, accountantId)\n    } else if (action === 'unlink') {\n      return await handleUnlinkTransaction(receipt, accountantId)\n    }\n\n  } catch (error) {\n    logger.error('Receipt matching service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error during receipt matching' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Handle suggesting matching transactions for a receipt\n */\nasync function handleSuggestMatches(receipt: any, accountantId: string) {\n  try {\n    if (!receipt.ocr_data) {\n      return NextResponse.json(\n        { error: 'Receipt has not been processed with OCR yet' },\n        { status: 400 }\n      )\n    }\n\n    // Find matching transactions\n    const matches = await findMatchingTransactions(receipt.ocr_data, accountantId)\n\n    // Get additional transaction details\n    const transactionIds = matches.map(m => m.transactionId)\n    const { data: transactions, error: transactionError } = await supabase\n      .from('transactions')\n      .select(`\n        id,\n        description,\n        amount,\n        vendor_name,\n        transaction_date,\n        account_name,\n        status,\n        category:transaction_categories(name)\n      `)\n      .in('id', transactionIds)\n\n    if (transactionError) {\n      throw new Error(`Failed to fetch transaction details: ${transactionError.message}`)\n    }\n\n    // Enhance matches with full transaction data\n    const enhancedMatches = matches.map(match => {\n      const transaction = transactions?.find(t => t.id === match.transactionId)\n      return {\n        ...match,\n        transaction: transaction ? {\n          ...transaction,\n          categoryName: transaction.category?.name\n        } : match.transaction\n      }\n    })\n\n    logger.info('Generated receipt matching suggestions', {\n      receiptId: receipt.id,\n      matchesFound: enhancedMatches.length,\n      topMatchScore: enhancedMatches[0]?.matchScore || 0\n    })\n\n    return NextResponse.json({\n      success: true,\n      receipt: {\n        id: receipt.id,\n        fileName: receipt.file_name,\n        ocr: {\n          vendor: receipt.vendor_extracted,\n          amount: receipt.amount_extracted,\n          date: receipt.date_extracted,\n          confidence: receipt.ocr_confidence\n        }\n      },\n      matches: enhancedMatches,\n      summary: {\n        totalMatches: enhancedMatches.length,\n        highConfidenceMatches: enhancedMatches.filter(m => m.matchScore > 0.8).length,\n        mediumConfidenceMatches: enhancedMatches.filter(m => m.matchScore > 0.5 && m.matchScore <= 0.8).length,\n        lowConfidenceMatches: enhancedMatches.filter(m => m.matchScore <= 0.5).length\n      }\n    })\n\n  } catch (error) {\n    logger.error('Error suggesting matches', error as Error, {\n      receiptId: receipt.id,\n      accountantId\n    })\n    throw error\n  }\n}\n\n/**\n * Handle linking a receipt to a specific transaction\n */\nasync function handleLinkTransaction(receipt: any, transactionId: string, accountantId: string) {\n  try {\n    if (!transactionId) {\n      return NextResponse.json(\n        { error: 'Transaction ID is required for linking' },\n        { status: 400 }\n      )\n    }\n\n    // Verify transaction belongs to accountant\n    const { data: transaction, error: transactionError } = await supabase\n      .from('transactions')\n      .select('id, description, amount, vendor_name, transaction_date')\n      .eq('id', transactionId)\n      .eq('accountant_id', accountantId)\n      .single()\n\n    if (transactionError || !transaction) {\n      return NextResponse.json(\n        { error: 'Transaction not found or unauthorized' },\n        { status: 404 }\n      )\n    }\n\n    // Check if transaction is already linked to another receipt\n    const { data: existingLink, error: linkCheckError } = await supabase\n      .from('receipts')\n      .select('id, file_name')\n      .eq('transaction_id', transactionId)\n      .neq('id', receipt.id)\n      .single()\n\n    if (linkCheckError && linkCheckError.code !== 'PGRST116') { // PGRST116 = no rows returned\n      throw new Error(`Failed to check existing links: ${linkCheckError.message}`)\n    }\n\n    if (existingLink) {\n      return NextResponse.json(\n        { \n          error: `Transaction is already linked to receipt: ${existingLink.file_name}`,\n          conflictingReceipt: {\n            id: existingLink.id,\n            fileName: existingLink.file_name\n          }\n        },\n        { status: 409 }\n      )\n    }\n\n    // Calculate match score for this specific pairing\n    let matchScore = 0\n    let matchReasons: string[] = []\n    \n    if (receipt.ocr_data) {\n      const matchResult = calculateDetailedMatchScore(receipt.ocr_data, transaction)\n      matchScore = matchResult.score\n      matchReasons = matchResult.reasons\n    }\n\n    // Link receipt to transaction\n    const { error: updateError } = await supabase\n      .from('receipts')\n      .update({\n        transaction_id: transactionId,\n        is_matched: true,\n        match_confidence: matchScore,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', receipt.id)\n\n    if (updateError) {\n      throw new Error(`Failed to link receipt to transaction: ${updateError.message}`)\n    }\n\n    // Log activity\n    await supabase.from('activity_logs').insert({\n      user_id: accountantId,\n      action: 'RECEIPT_LINK',\n      resource_type: 'receipt',\n      resource_id: receipt.id,\n      new_values: {\n        transactionId,\n        matchScore,\n        matchReasons\n      }\n    })\n\n    logger.info('Receipt linked to transaction', {\n      receiptId: receipt.id,\n      transactionId,\n      matchScore,\n      accountantId\n    })\n\n    return NextResponse.json({\n      success: true,\n      message: 'Receipt successfully linked to transaction',\n      link: {\n        receiptId: receipt.id,\n        transactionId,\n        matchScore,\n        matchReasons,\n        linkedAt: new Date().toISOString()\n      },\n      transaction: {\n        id: transaction.id,\n        description: transaction.description,\n        amount: transaction.amount,\n        vendor: transaction.vendor_name,\n        date: transaction.transaction_date\n      }\n    })\n\n  } catch (error) {\n    logger.error('Error linking receipt to transaction', error as Error, {\n      receiptId: receipt.id,\n      transactionId,\n      accountantId\n    })\n    throw error\n  }\n}\n\n/**\n * Handle unlinking a receipt from its transaction\n */\nasync function handleUnlinkTransaction(receipt: any, accountantId: string) {\n  try {\n    if (!receipt.transaction_id) {\n      return NextResponse.json(\n        { error: 'Receipt is not currently linked to any transaction' },\n        { status: 400 }\n      )\n    }\n\n    const previousTransactionId = receipt.transaction_id\n\n    // Unlink receipt from transaction\n    const { error: updateError } = await supabase\n      .from('receipts')\n      .update({\n        transaction_id: null,\n        is_matched: false,\n        match_confidence: 0,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', receipt.id)\n\n    if (updateError) {\n      throw new Error(`Failed to unlink receipt from transaction: ${updateError.message}`)\n    }\n\n    // Log activity\n    await supabase.from('activity_logs').insert({\n      user_id: accountantId,\n      action: 'RECEIPT_UNLINK',\n      resource_type: 'receipt',\n      resource_id: receipt.id,\n      old_values: {\n        transactionId: previousTransactionId\n      }\n    })\n\n    logger.info('Receipt unlinked from transaction', {\n      receiptId: receipt.id,\n      previousTransactionId,\n      accountantId\n    })\n\n    return NextResponse.json({\n      success: true,\n      message: 'Receipt successfully unlinked from transaction',\n      unlink: {\n        receiptId: receipt.id,\n        previousTransactionId,\n        unlinkedAt: new Date().toISOString()\n      }\n    })\n\n  } catch (error) {\n    logger.error('Error unlinking receipt from transaction', error as Error, {\n      receiptId: receipt.id,\n      accountantId\n    })\n    throw error\n  }\n}\n\n/**\n * Calculate detailed match score with enhanced logic\n */\nfunction calculateDetailedMatchScore(\n  ocrData: any,\n  transaction: any\n): { score: number; reasons: string[] } {\n  let score = 0\n  const reasons: string[] = []\n  const weights = {\n    amount: 0.5,\n    date: 0.3,\n    vendor: 0.2\n  }\n\n  // Enhanced amount matching\n  const ocrAmount = Math.abs(ocrData.amount.value)\n  const transactionAmount = Math.abs(transaction.amount)\n  const amountDiff = Math.abs(ocrAmount - transactionAmount)\n  const amountThreshold = Math.max(1, transactionAmount * 0.05) // 5% tolerance\n\n  if (amountDiff === 0) {\n    score += weights.amount\n    reasons.push(`Exact amount match: $${ocrAmount}`)\n  } else if (amountDiff <= amountThreshold) {\n    score += weights.amount * 0.9\n    reasons.push(`Amount match within 5%: $${ocrAmount} ≈ $${transactionAmount}`)\n  } else if (amountDiff <= amountThreshold * 2) {\n    score += weights.amount * 0.7\n    reasons.push(`Amount close within 10%: $${ocrAmount} ≈ $${transactionAmount}`)\n  } else if (amountDiff <= amountThreshold * 4) {\n    score += weights.amount * 0.3\n    reasons.push(`Amount somewhat close: $${ocrAmount} vs $${transactionAmount}`)\n  }\n\n  // Enhanced date matching\n  const ocrDate = new Date(ocrData.date.value)\n  const transactionDate = new Date(transaction.transaction_date)\n  const daysDiff = Math.abs((ocrDate.getTime() - transactionDate.getTime()) / (1000 * 60 * 60 * 24))\n\n  if (daysDiff === 0) {\n    score += weights.date\n    reasons.push('Same date')\n  } else if (daysDiff <= 1) {\n    score += weights.date * 0.9\n    reasons.push('Within 1 day')\n  } else if (daysDiff <= 3) {\n    score += weights.date * 0.7\n    reasons.push('Within 3 days')\n  } else if (daysDiff <= 7) {\n    score += weights.date * 0.4\n    reasons.push('Within 1 week')\n  } else if (daysDiff <= 14) {\n    score += weights.date * 0.2\n    reasons.push('Within 2 weeks')\n  }\n\n  // Enhanced vendor matching\n  if (transaction.vendor_name && ocrData.vendor.name) {\n    const ocrVendor = ocrData.vendor.name.toLowerCase().trim()\n    const transactionVendor = transaction.vendor_name.toLowerCase().trim()\n    \n    if (ocrVendor === transactionVendor) {\n      score += weights.vendor\n      reasons.push('Exact vendor match')\n    } else {\n      // Check for partial matches\n      const similarity = calculateAdvancedStringSimilarity(ocrVendor, transactionVendor)\n      \n      if (similarity > 0.9) {\n        score += weights.vendor * 0.9\n        reasons.push('Very similar vendor names')\n      } else if (similarity > 0.7) {\n        score += weights.vendor * 0.7\n        reasons.push('Similar vendor names')\n      } else if (similarity > 0.5) {\n        score += weights.vendor * 0.4\n        reasons.push('Somewhat similar vendor names')\n      }\n      \n      // Check for common vendor abbreviations/variations\n      if (checkVendorAliases(ocrVendor, transactionVendor)) {\n        score += weights.vendor * 0.8\n        reasons.push('Vendor name variation detected')\n      }\n    }\n  }\n\n  // Bonus points for high OCR confidence\n  if (ocrData.vendor.confidence > 0.9 && ocrData.amount.confidence > 0.9) {\n    score += 0.1\n    reasons.push('High OCR confidence')\n  }\n\n  return { \n    score: Math.min(score, 1.0), \n    reasons: reasons.slice(0, 5) // Limit to top 5 reasons\n  }\n}\n\n/**\n * Advanced string similarity with fuzzy matching\n */\nfunction calculateAdvancedStringSimilarity(str1: string, str2: string): number {\n  // Normalize strings\n  const normalize = (s: string) => s.toLowerCase().replace(/[^a-z0-9]/g, '')\n  const norm1 = normalize(str1)\n  const norm2 = normalize(str2)\n  \n  if (norm1 === norm2) return 1.0\n  if (norm1.length === 0 || norm2.length === 0) return 0.0\n  \n  // Check for substring matches\n  if (norm1.includes(norm2) || norm2.includes(norm1)) {\n    const longer = norm1.length > norm2.length ? norm1 : norm2\n    const shorter = norm1.length <= norm2.length ? norm1 : norm2\n    return shorter.length / longer.length\n  }\n  \n  // Levenshtein distance\n  const matrix = []\n  for (let i = 0; i <= norm1.length; i++) {\n    matrix[i] = [i]\n  }\n  for (let j = 0; j <= norm2.length; j++) {\n    matrix[0][j] = j\n  }\n  \n  for (let i = 1; i <= norm1.length; i++) {\n    for (let j = 1; j <= norm2.length; j++) {\n      const cost = norm1[i - 1] === norm2[j - 1] ? 0 : 1\n      matrix[i][j] = Math.min(\n        matrix[i - 1][j] + 1,\n        matrix[i][j - 1] + 1,\n        matrix[i - 1][j - 1] + cost\n      )\n    }\n  }\n  \n  const maxLen = Math.max(norm1.length, norm2.length)\n  return (maxLen - matrix[norm1.length][norm2.length]) / maxLen\n}\n\n/**\n * Check for common vendor name aliases and variations\n */\nfunction checkVendorAliases(vendor1: string, vendor2: string): boolean {\n  const aliases = [\n    ['starbucks', 'sbux', 'starbucks coffee'],\n    ['mcdonalds', 'mcdonald\\'s', 'mcd', 'golden arches'],\n    ['walmart', 'wal-mart', 'wm'],\n    ['target', 'tgt'],\n    ['amazon', 'amzn', 'amazon.com'],\n    ['microsoft', 'msft', 'ms'],\n    ['apple', 'apple inc', 'apple store'],\n    ['google', 'alphabet', 'google inc'],\n    ['uber', 'uber technologies'],\n    ['lyft', 'lyft inc']\n  ]\n  \n  for (const aliasGroup of aliases) {\n    const hasVendor1 = aliasGroup.some(alias => vendor1.includes(alias))\n    const hasVendor2 = aliasGroup.some(alias => vendor2.includes(alias))\n    if (hasVendor1 && hasVendor2) {\n      return true\n    }\n  }\n  \n  return false\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const accountantId = searchParams.get('accountantId')\n    const status = searchParams.get('status') // matched, unmatched, all\n    const limit = parseInt(searchParams.get('limit') || '50')\n\n    if (!accountantId) {\n      return NextResponse.json(\n        { error: 'Missing accountantId parameter' },\n        { status: 400 }\n      )\n    }\n\n    // Build query for receipt matching statistics\n    let query = supabase\n      .from('receipts')\n      .select(`\n        id,\n        file_name,\n        vendor_extracted,\n        amount_extracted,\n        date_extracted,\n        is_matched,\n        match_confidence,\n        transaction_id,\n        processed_at,\n        client:clients!inner(accountant_id),\n        transaction:transactions(id, description, amount, transaction_date)\n      `)\n      .eq('client.accountant_id', accountantId)\n      .not('processed_at', 'is', null)\n      .order('processed_at', { ascending: false })\n      .limit(limit)\n\n    // Apply status filter\n    if (status === 'matched') {\n      query = query.eq('is_matched', true)\n    } else if (status === 'unmatched') {\n      query = query.eq('is_matched', false)\n    }\n\n    const { data: receipts, error } = await query\n\n    if (error) {\n      const dbError = new DatabaseError('Failed to fetch receipt matching data', {\n        accountantId,\n        dbError: error.message\n      })\n      logger.error('Database error fetching receipt matching data', dbError)\n      return NextResponse.json(\n        { error: dbError.message },\n        { status: dbError.statusCode }\n      )\n    }\n\n    // Calculate statistics\n    const stats = {\n      totalProcessed: receipts?.length || 0,\n      matched: receipts?.filter(r => r.is_matched).length || 0,\n      unmatched: receipts?.filter(r => !r.is_matched).length || 0,\n      averageMatchConfidence: receipts?.length ? \n        receipts.reduce((sum, r) => sum + (r.match_confidence || 0), 0) / receipts.length : 0,\n      highConfidenceMatches: receipts?.filter(r => (r.match_confidence || 0) > 0.8).length || 0,\n      mediumConfidenceMatches: receipts?.filter(r => (r.match_confidence || 0) > 0.5 && (r.match_confidence || 0) <= 0.8).length || 0,\n      lowConfidenceMatches: receipts?.filter(r => (r.match_confidence || 0) <= 0.5 && r.is_matched).length || 0\n    }\n\n    return NextResponse.json({\n      success: true,\n      statistics: stats,\n      receipts: receipts?.map(receipt => ({\n        id: receipt.id,\n        fileName: receipt.file_name,\n        vendor: receipt.vendor_extracted,\n        amount: receipt.amount_extracted,\n        date: receipt.date_extracted,\n        isMatched: receipt.is_matched,\n        matchConfidence: receipt.match_confidence,\n        transaction: receipt.transaction\n      })) || []\n    })\n\n  } catch (error) {\n    logger.error('Receipt matching statistics service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error fetching receipt matching data' },\n      { status: 500 }\n    )\n  }\n}\n"