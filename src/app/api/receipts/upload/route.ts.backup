import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { processReceiptOCR, findMatchingTransactions } from '@/lib/integrations/mindee-ocr'\nimport { logger } from '@/lib/logger'\nimport { ValidationError, DatabaseError, FileUploadError } from '@/lib/errors'\nimport { APP_CONFIG } from '@/lib/config'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData()\n    const file = formData.get('receipt') as File\n    const clientId = formData.get('clientId') as string\n    const accountantId = formData.get('accountantId') as string\n    const description = formData.get('description') as string || ''\n\n    // Validate required fields\n    if (!file || !clientId || !accountantId) {\n      const error = new ValidationError('Missing required fields: receipt file, clientId, accountantId', {\n        hasFile: !!file,\n        clientId: !!clientId,\n        accountantId: !!accountantId\n      })\n      logger.error('Receipt upload validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Validate file\n    if (file.size > APP_CONFIG.UPLOAD.MAX_FILE_SIZE) {\n      const error = new FileUploadError(`File size ${file.size} exceeds maximum ${APP_CONFIG.UPLOAD.MAX_FILE_SIZE} bytes`)\n      logger.error('File size validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    if (!APP_CONFIG.UPLOAD.ALLOWED_MIME_TYPES.includes(file.type)) {\n      const error = new FileUploadError(`Unsupported file type: ${file.type}. Allowed types: ${APP_CONFIG.UPLOAD.ALLOWED_MIME_TYPES.join(', ')}`)\n      logger.error('File type validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Verify client belongs to accountant\n    const { data: client, error: clientError } = await supabase\n      .from('clients')\n      .select('id, accountant_id')\n      .eq('id', clientId)\n      .eq('accountant_id', accountantId)\n      .single()\n\n    if (clientError || !client) {\n      const error = new ValidationError('Invalid client or accountant relationship', {\n        clientId,\n        accountantId,\n        dbError: clientError?.message\n      })\n      logger.error('Client validation failed', error)\n      return NextResponse.json(\n        { error: 'Unauthorized: Invalid client access' },\n        { status: 403 }\n      )\n    }\n\n    // Convert file to buffer\n    const fileBuffer = Buffer.from(await file.arrayBuffer())\n    const fileName = file.name\n    const mimeType = file.type\n\n    // Generate unique file path\n    const timestamp = Date.now()\n    const fileExtension = fileName.split('.').pop() || 'unknown'\n    const storagePath = `receipts/${accountantId}/${clientId}/${timestamp}_${fileName}`\n\n    // Upload file to Supabase storage\n    const { data: uploadData, error: uploadError } = await supabase.storage\n      .from('receipts')\n      .upload(storagePath, fileBuffer, {\n        contentType: mimeType,\n        metadata: {\n          clientId,\n          accountantId,\n          originalName: fileName,\n          uploadedAt: new Date().toISOString()\n        }\n      })\n\n    if (uploadError) {\n      const error = new FileUploadError('Failed to upload file to storage', {\n        fileName,\n        mimeType,\n        storageError: uploadError.message\n      })\n      logger.error('File storage upload failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Create receipt record in database\n    const { data: receiptRecord, error: receiptError } = await supabase\n      .from('receipts')\n      .insert({\n        client_id: clientId,\n        file_path: uploadData.path,\n        file_name: fileName,\n        file_size: file.size,\n        mime_type: mimeType,\n        uploaded_at: new Date().toISOString()\n      })\n      .select()\n      .single()\n\n    if (receiptError) {\n      // Clean up uploaded file if database insert fails\n      await supabase.storage.from('receipts').remove([uploadData.path])\n      \n      const error = new DatabaseError('Failed to create receipt record', {\n        fileName,\n        storageError: receiptError.message\n      })\n      logger.error('Receipt database insert failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Process OCR asynchronously (don't wait for completion)\n    processReceiptAsync(receiptRecord.id, fileBuffer, fileName, mimeType, accountantId)\n      .catch(error => {\n        logger.error('Async OCR processing failed', error, {\n          receiptId: receiptRecord.id,\n          fileName\n        })\n      })\n\n    // Log activity\n    await supabase.from('activity_logs').insert({\n      user_id: clientId,\n      action: 'RECEIPT_UPLOAD',\n      resource_type: 'receipt',\n      resource_id: receiptRecord.id,\n      new_values: {\n        fileName,\n        fileSize: file.size,\n        mimeType\n      }\n    })\n\n    return NextResponse.json({\n      success: true,\n      receipt: {\n        id: receiptRecord.id,\n        fileName,\n        fileSize: file.size,\n        uploadedAt: receiptRecord.uploaded_at,\n        status: 'uploaded',\n        processingStatus: 'queued'\n      },\n      message: 'Receipt uploaded successfully. OCR processing started.'\n    })\n\n  } catch (error) {\n    logger.error('Receipt upload service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error during receipt upload' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Process receipt OCR asynchronously\n */\nasync function processReceiptAsync(\n  receiptId: string,\n  fileBuffer: Buffer,\n  fileName: string,\n  mimeType: string,\n  accountantId: string\n): Promise<void> {\n  try {\n    logger.info('Starting async OCR processing', { receiptId, fileName })\n\n    // Process OCR\n    const ocrResult = await processReceiptOCR(fileBuffer, fileName, mimeType)\n\n    // Find matching transactions\n    const matchingTransactions = await findMatchingTransactions(\n      ocrResult.data,\n      accountantId\n    )\n\n    // Update receipt with OCR data and matches\n    const { error: updateError } = await supabase\n      .from('receipts')\n      .update({\n        ocr_data: ocrResult.data,\n        ocr_confidence: ocrResult.confidence === 'high' ? 0.9 : \n                       ocrResult.confidence === 'medium' ? 0.7 : 0.5,\n        vendor_extracted: ocrResult.data.vendor.name,\n        amount_extracted: ocrResult.data.amount.value,\n        date_extracted: ocrResult.data.date.value,\n        processed_at: new Date().toISOString(),\n        is_matched: matchingTransactions.length > 0,\n        match_confidence: matchingTransactions.length > 0 ? matchingTransactions[0].matchScore : 0\n      })\n      .eq('id', receiptId)\n\n    if (updateError) {\n      throw new Error(`Failed to update receipt with OCR data: ${updateError.message}`)\n    }\n\n    // If we found a high-confidence match, link it automatically\n    if (matchingTransactions.length > 0 && matchingTransactions[0].matchScore > 0.8) {\n      const bestMatch = matchingTransactions[0]\n      \n      const { error: linkError } = await supabase\n        .from('receipts')\n        .update({\n          transaction_id: bestMatch.transactionId\n        })\n        .eq('id', receiptId)\n\n      if (linkError) {\n        logger.error('Failed to auto-link receipt to transaction', linkError, {\n          receiptId,\n          transactionId: bestMatch.transactionId\n        })\n      } else {\n        logger.info('Auto-linked receipt to transaction', {\n          receiptId,\n          transactionId: bestMatch.transactionId,\n          matchScore: bestMatch.matchScore\n        })\n      }\n    }\n\n    logger.info('OCR processing completed successfully', {\n      receiptId,\n      confidence: ocrResult.confidence,\n      vendor: ocrResult.data.vendor.name,\n      amount: ocrResult.data.amount.value,\n      matchesFound: matchingTransactions.length\n    })\n\n  } catch (error) {\n    logger.error('OCR processing failed', error as Error, { receiptId, fileName })\n    \n    // Update receipt with error status\n    await supabase\n      .from('receipts')\n      .update({\n        processed_at: new Date().toISOString(),\n        ocr_confidence: 0,\n        vendor_extracted: 'Processing Failed',\n        amount_extracted: 0\n      })\n      .eq('id', receiptId)\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const clientId = searchParams.get('clientId')\n    const accountantId = searchParams.get('accountantId')\n    const status = searchParams.get('status') // uploaded, processed, matched\n    const limit = parseInt(searchParams.get('limit') || '50')\n\n    if (!clientId || !accountantId) {\n      return NextResponse.json(\n        { error: 'Missing clientId or accountantId parameter' },\n        { status: 400 }\n      )\n    }\n\n    // Verify client belongs to accountant\n    const { data: client, error: clientError } = await supabase\n      .from('clients')\n      .select('id')\n      .eq('id', clientId)\n      .eq('accountant_id', accountantId)\n      .single()\n\n    if (clientError || !client) {\n      return NextResponse.json(\n        { error: 'Unauthorized: Invalid client access' },\n        { status: 403 }\n      )\n    }\n\n    // Build query\n    let query = supabase\n      .from('receipts')\n      .select(`\n        *,\n        transaction:transactions(id, description, amount, transaction_date)\n      `)\n      .eq('client_id', clientId)\n      .order('uploaded_at', { ascending: false })\n      .limit(limit)\n\n    // Apply status filter\n    if (status === 'processed') {\n      query = query.not('processed_at', 'is', null)\n    } else if (status === 'matched') {\n      query = query.not('transaction_id', 'is', null)\n    } else if (status === 'uploaded') {\n      query = query.is('processed_at', null)\n    }\n\n    const { data: receipts, error } = await query\n\n    if (error) {\n      const dbError = new DatabaseError('Failed to fetch receipts', {\n        clientId,\n        accountantId,\n        dbError: error.message\n      })\n      logger.error('Database error fetching receipts', dbError)\n      return NextResponse.json(\n        { error: dbError.message },\n        { status: dbError.statusCode }\n      )\n    }\n\n    // Format response\n    const formattedReceipts = receipts?.map(receipt => ({\n      id: receipt.id,\n      fileName: receipt.file_name,\n      fileSize: receipt.file_size,\n      mimeType: receipt.mime_type,\n      uploadedAt: receipt.uploaded_at,\n      processedAt: receipt.processed_at,\n      status: receipt.processed_at ? 'processed' : 'uploaded',\n      ocr: receipt.ocr_data ? {\n        vendor: receipt.vendor_extracted,\n        amount: receipt.amount_extracted,\n        date: receipt.date_extracted,\n        confidence: receipt.ocr_confidence\n      } : null,\n      matching: {\n        isMatched: receipt.is_matched,\n        confidence: receipt.match_confidence,\n        transaction: receipt.transaction\n      }\n    })) || []\n\n    return NextResponse.json({\n      success: true,\n      receipts: formattedReceipts,\n      total: formattedReceipts.length\n    })\n\n  } catch (error) {\n    logger.error('Receipt list service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error fetching receipts' },\n      { status: 500 }\n    )\n  }\n}\n"