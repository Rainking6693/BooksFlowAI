import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '@/lib/supabase'\nimport { makeQBApiCall, getQBConnection } from '@/lib/integrations/quickbooks'\nimport { logger } from '@/lib/logger'\nimport { ValidationError, DatabaseError, QuickBooksError } from '@/lib/errors'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { transactionIds, accountantId, action } = body\n\n    // Validate required fields\n    if (!transactionIds || !accountantId || !action) {\n      const error = new ValidationError('Missing required fields: transactionIds, accountantId, action', {\n        transactionIds: !!transactionIds,\n        accountantId: !!accountantId,\n        action: !!action\n      })\n      logger.error('Transaction approval validation failed', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    if (!['approve', 'reject'].includes(action)) {\n      const error = new ValidationError('Action must be either \"approve\" or \"reject\"', {\n        providedAction: action\n      })\n      logger.error('Invalid action provided', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    // Get transactions to approve/reject\n    const { data: transactions, error: transactionsError } = await supabase\n      .from('transactions')\n      .select('*')\n      .in('id', transactionIds)\n      .eq('accountant_id', accountantId)\n      .eq('status', 'pending')\n\n    if (transactionsError) {\n      const error = new DatabaseError('Failed to fetch transactions', {\n        accountantId,\n        transactionIds,\n        dbError: transactionsError.message\n      })\n      logger.error('Database error fetching transactions', error)\n      return NextResponse.json(\n        { error: error.message },\n        { status: error.statusCode }\n      )\n    }\n\n    if (!transactions || transactions.length === 0) {\n      return NextResponse.json(\n        { error: 'No pending transactions found' },\n        { status: 404 }\n      )\n    }\n\n    const results = []\n    const errors = []\n\n    // Process each transaction\n    for (const transaction of transactions) {\n      try {\n        if (action === 'approve') {\n          // Update transaction in QuickBooks if it has a QuickBooks ID\n          if (transaction.quickbooks_id && transaction.ai_suggested_category_id) {\n            await updateQuickBooksTransaction(\n              accountantId,\n              transaction.quickbooks_id,\n              transaction.ai_suggested_category_id\n            )\n          }\n\n          // Update transaction status in database\n          const { error: updateError } = await supabase\n            .from('transactions')\n            .update({\n              status: 'approved',\n              category_id: transaction.ai_suggested_category_id,\n              reviewed_by: accountantId,\n              reviewed_at: new Date().toISOString(),\n              updated_at: new Date().toISOString()\n            })\n            .eq('id', transaction.id)\n\n          if (updateError) {\n            throw new DatabaseError('Failed to update transaction status', {\n              transactionId: transaction.id,\n              dbError: updateError.message\n            })\n          }\n\n          results.push({\n            transactionId: transaction.id,\n            status: 'approved',\n            message: 'Transaction approved and synced to QuickBooks'\n          })\n        } else {\n          // Reject transaction\n          const { error: updateError } = await supabase\n            .from('transactions')\n            .update({\n              status: 'rejected',\n              reviewed_by: accountantId,\n              reviewed_at: new Date().toISOString(),\n              updated_at: new Date().toISOString()\n            })\n            .eq('id', transaction.id)\n\n          if (updateError) {\n            throw new DatabaseError('Failed to update transaction status', {\n              transactionId: transaction.id,\n              dbError: updateError.message\n            })\n          }\n\n          results.push({\n            transactionId: transaction.id,\n            status: 'rejected',\n            message: 'Transaction rejected'\n          })\n        }\n\n        // Log activity\n        await supabase.from('activity_logs').insert({\n          user_id: accountantId,\n          action: action.toUpperCase(),\n          resource_type: 'transaction',\n          resource_id: transaction.id,\n          new_values: {\n            status: action === 'approve' ? 'approved' : 'rejected',\n            category_id: action === 'approve' ? transaction.ai_suggested_category_id : null\n          }\n        })\n\n      } catch (error) {\n        logger.error(`Failed to ${action} transaction ${transaction.id}`, error as Error)\n        errors.push({\n          transactionId: transaction.id,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        })\n      }\n    }\n\n    return NextResponse.json({\n      success: true,\n      processed: results.length,\n      results,\n      errors: errors.length > 0 ? errors : undefined,\n      summary: {\n        approved: results.filter(r => r.status === 'approved').length,\n        rejected: results.filter(r => r.status === 'rejected').length,\n        failed: errors.length\n      }\n    })\n\n  } catch (error) {\n    logger.error('Transaction approval service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error during transaction approval' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Update transaction category in QuickBooks\n */\nasync function updateQuickBooksTransaction(\n  accountantId: string,\n  quickbooksTransactionId: string,\n  categoryId: string\n): Promise<void> {\n  try {\n    // Get QuickBooks connection\n    const connection = await getQBConnection(accountantId)\n    \n    // Get category details\n    const { data: category, error: categoryError } = await supabase\n      .from('transaction_categories')\n      .select('quickbooks_id, name')\n      .eq('id', categoryId)\n      .single()\n\n    if (categoryError || !category) {\n      throw new DatabaseError('Failed to fetch category details', {\n        categoryId,\n        dbError: categoryError?.message\n      })\n    }\n\n    if (!category.quickbooks_id) {\n      logger.warn('Category does not have QuickBooks ID, skipping QB update', {\n        categoryId,\n        categoryName: category.name\n      })\n      return\n    }\n\n    // Update transaction in QuickBooks\n    // Note: This is a simplified example - actual implementation depends on transaction type\n    const updateData = {\n      AccountRef: {\n        value: category.quickbooks_id\n      },\n      sparse: true\n    }\n\n    await makeQBApiCall(\n      `items/${quickbooksTransactionId}`,\n      connection.access_token_encrypted, // TODO: Decrypt in production\n      connection.company_id,\n      'POST',\n      updateData\n    )\n\n    logger.info('Successfully updated transaction in QuickBooks', {\n      transactionId: quickbooksTransactionId,\n      categoryId: category.quickbooks_id,\n      categoryName: category.name\n    })\n\n  } catch (error) {\n    throw new QuickBooksError('Failed to update transaction in QuickBooks', {\n      transactionId: quickbooksTransactionId,\n      categoryId,\n      originalError: error instanceof Error ? error.message : 'Unknown error'\n    })\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const accountantId = searchParams.get('accountantId')\n\n    if (!accountantId) {\n      return NextResponse.json(\n        { error: 'Missing accountantId parameter' },\n        { status: 400 }\n      )\n    }\n\n    // Get approval statistics\n    const { data: transactions, error } = await supabase\n      .from('transactions')\n      .select('status, reviewed_at, ai_confidence')\n      .eq('accountant_id', accountantId)\n      .not('status', 'eq', 'pending')\n      .order('reviewed_at', { ascending: false })\n      .limit(100)\n\n    if (error) {\n      const dbError = new DatabaseError('Failed to fetch approval statistics', {\n        accountantId,\n        dbError: error.message\n      })\n      logger.error('Database error fetching approval stats', dbError)\n      return NextResponse.json(\n        { error: dbError.message },\n        { status: dbError.statusCode }\n      )\n    }\n\n    const stats = {\n      totalReviewed: transactions?.length || 0,\n      approved: transactions?.filter(t => t.status === 'approved').length || 0,\n      rejected: transactions?.filter(t => t.status === 'rejected').length || 0,\n      approvalRate: transactions?.length ? \n        (transactions.filter(t => t.status === 'approved').length / transactions.length * 100).toFixed(1) : '0',\n      confidenceBreakdown: {\n        high: transactions?.filter(t => t.ai_confidence === 'high' && t.status === 'approved').length || 0,\n        medium: transactions?.filter(t => t.ai_confidence === 'medium' && t.status === 'approved').length || 0,\n        low: transactions?.filter(t => t.ai_confidence === 'low' && t.status === 'approved').length || 0\n      },\n      recentActivity: transactions?.slice(0, 10).map(t => ({\n        status: t.status,\n        reviewedAt: t.reviewed_at,\n        confidence: t.ai_confidence\n      })) || []\n    }\n\n    return NextResponse.json({\n      success: true,\n      statistics: stats\n    })\n\n  } catch (error) {\n    logger.error('Approval statistics service error', error as Error)\n    return NextResponse.json(\n      { error: 'Internal server error fetching approval statistics' },\n      { status: 500 }\n    )\n  }\n}\n"