/**\n * Mindee OCR API Integration\n * Handles receipt processing and data extraction\n */\n\nimport { logger } from '../logger'\nimport { ExternalServiceError, withRetry, CircuitBreaker } from '../errors'\nimport { APP_CONFIG } from '../config'\n\n// Mindee API Configuration\nconst MINDEE_CONFIG = {\n  API_URL: 'https://api.mindee.net/v1',\n  API_KEY: process.env.MINDEE_API_KEY!,\n  TIMEOUT: 30000, // 30 seconds\n  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB\n  SUPPORTED_FORMATS: ['image/jpeg', 'image/png', 'image/webp', 'application/pdf'],\n  RETRY_ATTEMPTS: 3,\n  RETRY_DELAY: 1000\n}\n\n// Circuit breaker for Mindee API resilience\nconst mindeeCircuitBreaker = new CircuitBreaker(5, 60000, 'Mindee-OCR')\n\n// OCR Result Types\nexport interface OCRReceiptData {\n  vendor: {\n    name: string\n    confidence: number\n  }\n  amount: {\n    value: number\n    currency: string\n    confidence: number\n  }\n  date: {\n    value: string // ISO date string\n    confidence: number\n  }\n  category: {\n    predicted: string\n    confidence: number\n  }\n  lineItems: Array<{\n    description: string\n    amount: number\n    quantity?: number\n  }>\n  taxAmount?: {\n    value: number\n    confidence: number\n  }\n  tipAmount?: {\n    value: number\n    confidence: number\n  }\n  paymentMethod?: {\n    type: string\n    confidence: number\n  }\n}\n\nexport interface OCRProcessingResult {\n  success: boolean\n  confidence: 'high' | 'medium' | 'low'\n  data: OCRReceiptData\n  rawResponse: any\n  processingTime: number\n  errors?: string[]\n}\n\nexport interface ReceiptMatchingCandidate {\n  transactionId: string\n  matchScore: number\n  matchReasons: string[]\n  transaction: {\n    description: string\n    amount: number\n    date: string\n    vendor?: string\n  }\n}\n\n/**\n * Process receipt image/PDF using Mindee OCR\n */\nexport async function processReceiptOCR(\n  fileBuffer: Buffer,\n  fileName: string,\n  mimeType: string\n): Promise<OCRProcessingResult> {\n  const startTime = Date.now()\n  \n  try {\n    // Validate file\n    validateReceiptFile(fileBuffer, fileName, mimeType)\n    \n    // Process with Mindee API\n    const ocrResult = await mindeeCircuitBreaker.execute(() =>\n      withRetry(\n        () => callMindeeAPI(fileBuffer, fileName, mimeType),\n        MINDEE_CONFIG.RETRY_ATTEMPTS,\n        MINDEE_CONFIG.RETRY_DELAY,\n        { fileName, mimeType }\n      )\n    )\n    \n    // Parse and structure the response\n    const structuredData = parseOCRResponse(ocrResult)\n    const confidence = calculateOverallConfidence(structuredData)\n    \n    const processingTime = Date.now() - startTime\n    \n    logger.info('Receipt OCR processing completed', {\n      fileName,\n      confidence,\n      processingTime,\n      vendor: structuredData.vendor.name,\n      amount: structuredData.amount.value\n    })\n    \n    return {\n      success: true,\n      confidence,\n      data: structuredData,\n      rawResponse: ocrResult,\n      processingTime\n    }\n    \n  } catch (error) {\n    const processingTime = Date.now() - startTime\n    \n    logger.error('Receipt OCR processing failed', error as Error, {\n      fileName,\n      mimeType,\n      processingTime\n    })\n    \n    throw new ExternalServiceError(\n      'Mindee OCR',\n      `Failed to process receipt: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      { fileName, mimeType, processingTime }\n    )\n  }\n}\n\n/**\n * Validate receipt file before processing\n */\nfunction validateReceiptFile(buffer: Buffer, fileName: string, mimeType: string): void {\n  // Check file size\n  if (buffer.length > MINDEE_CONFIG.MAX_FILE_SIZE) {\n    throw new Error(`File size ${buffer.length} exceeds maximum ${MINDEE_CONFIG.MAX_FILE_SIZE} bytes`)\n  }\n  \n  // Check file format\n  if (!MINDEE_CONFIG.SUPPORTED_FORMATS.includes(mimeType)) {\n    throw new Error(`Unsupported file format: ${mimeType}. Supported formats: ${MINDEE_CONFIG.SUPPORTED_FORMATS.join(', ')}`)\n  }\n  \n  // Check file name\n  if (!fileName || fileName.length > 255) {\n    throw new Error('Invalid file name')\n  }\n}\n\n/**\n * Call Mindee API for receipt processing\n */\nasync function callMindeeAPI(\n  fileBuffer: Buffer,\n  fileName: string,\n  mimeType: string\n): Promise<any> {\n  const formData = new FormData()\n  \n  // Create blob from buffer\n  const blob = new Blob([fileBuffer], { type: mimeType })\n  formData.append('document', blob, fileName)\n  \n  const response = await fetch(`${MINDEE_CONFIG.API_URL}/products/mindee/expense_receipts/v5/predict`, {\n    method: 'POST',\n    headers: {\n      'Authorization': `Token ${MINDEE_CONFIG.API_KEY}`,\n      // Don't set Content-Type - let browser set it with boundary for FormData\n    },\n    body: formData,\n    signal: AbortSignal.timeout(MINDEE_CONFIG.TIMEOUT)\n  })\n  \n  if (!response.ok) {\n    const errorText = await response.text()\n    throw new Error(`Mindee API error (${response.status}): ${errorText}`)\n  }\n  \n  return response.json()\n}\n\n/**\n * Parse Mindee OCR response into structured data\n */\nfunction parseOCRResponse(response: any): OCRReceiptData {\n  const prediction = response.document?.inference?.prediction\n  \n  if (!prediction) {\n    throw new Error('Invalid OCR response format')\n  }\n  \n  // Extract vendor information\n  const vendor = {\n    name: prediction.supplier_name?.value || 'Unknown Vendor',\n    confidence: prediction.supplier_name?.confidence || 0\n  }\n  \n  // Extract amount information\n  const totalAmount = prediction.total_amount\n  const amount = {\n    value: totalAmount?.value || 0,\n    currency: totalAmount?.currency || 'USD',\n    confidence: totalAmount?.confidence || 0\n  }\n  \n  // Extract date information\n  const receiptDate = prediction.date\n  const date = {\n    value: receiptDate?.value || new Date().toISOString().split('T')[0],\n    confidence: receiptDate?.confidence || 0\n  }\n  \n  // Predict category based on vendor and line items\n  const category = predictReceiptCategory(vendor.name, prediction.line_items || [])\n  \n  // Extract line items\n  const lineItems = (prediction.line_items || []).map((item: any) => ({\n    description: item.description || '',\n    amount: item.total_amount || 0,\n    quantity: item.quantity || 1\n  }))\n  \n  // Extract additional fields\n  const taxAmount = prediction.taxes?.length > 0 ? {\n    value: prediction.taxes[0].value || 0,\n    confidence: prediction.taxes[0].confidence || 0\n  } : undefined\n  \n  const tipAmount = prediction.tip ? {\n    value: prediction.tip.value || 0,\n    confidence: prediction.tip.confidence || 0\n  } : undefined\n  \n  const paymentMethod = prediction.payment_method ? {\n    type: prediction.payment_method.value || 'unknown',\n    confidence: prediction.payment_method.confidence || 0\n  } : undefined\n  \n  return {\n    vendor,\n    amount,\n    date,\n    category,\n    lineItems,\n    taxAmount,\n    tipAmount,\n    paymentMethod\n  }\n}\n\n/**\n * Predict receipt category based on vendor and line items\n */\nfunction predictReceiptCategory(vendorName: string, lineItems: any[]): { predicted: string; confidence: number } {\n  const vendor = vendorName.toLowerCase()\n  \n  // Restaurant/Food patterns\n  if (vendor.includes('restaurant') || vendor.includes('cafe') || vendor.includes('coffee') ||\n      vendor.includes('starbucks') || vendor.includes('mcdonald') || vendor.includes('subway')) {\n    return { predicted: 'Meals & Entertainment', confidence: 0.9 }\n  }\n  \n  // Office supplies patterns\n  if (vendor.includes('office') || vendor.includes('staples') || vendor.includes('depot') ||\n      vendor.includes('supplies')) {\n    return { predicted: 'Office Supplies', confidence: 0.85 }\n  }\n  \n  // Travel patterns\n  if (vendor.includes('uber') || vendor.includes('lyft') || vendor.includes('taxi') ||\n      vendor.includes('hotel') || vendor.includes('airline') || vendor.includes('airport')) {\n    return { predicted: 'Travel', confidence: 0.85 }\n  }\n  \n  // Gas/Fuel patterns\n  if (vendor.includes('shell') || vendor.includes('exxon') || vendor.includes('chevron') ||\n      vendor.includes('gas') || vendor.includes('fuel')) {\n    return { predicted: 'Vehicle Expenses', confidence: 0.8 }\n  }\n  \n  // Technology patterns\n  if (vendor.includes('apple') || vendor.includes('microsoft') || vendor.includes('amazon') ||\n      vendor.includes('software') || vendor.includes('tech')) {\n    return { predicted: 'Software/Technology', confidence: 0.75 }\n  }\n  \n  // Default to general business expense\n  return { predicted: 'General Business Expense', confidence: 0.3 }\n}\n\n/**\n * Calculate overall confidence based on individual field confidences\n */\nfunction calculateOverallConfidence(data: OCRReceiptData): 'high' | 'medium' | 'low' {\n  const confidences = [\n    data.vendor.confidence,\n    data.amount.confidence,\n    data.date.confidence\n  ]\n  \n  const avgConfidence = confidences.reduce((sum, conf) => sum + conf, 0) / confidences.length\n  \n  if (avgConfidence >= 0.8) return 'high'\n  if (avgConfidence >= 0.6) return 'medium'\n  return 'low'\n}\n\n/**\n * Find matching transactions for a processed receipt\n */\nexport async function findMatchingTransactions(\n  ocrData: OCRReceiptData,\n  accountantId: string,\n  dateRange: { start: string; end: string } = {\n    start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 days ago\n    end: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] // 7 days future\n  }\n): Promise<ReceiptMatchingCandidate[]> {\n  try {\n    // Import supabase here to avoid circular dependencies\n    const { supabase } = await import('../supabase')\n    \n    // Get transactions within date range\n    const { data: transactions, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('accountant_id', accountantId)\n      .gte('transaction_date', dateRange.start)\n      .lte('transaction_date', dateRange.end)\n      .order('transaction_date', { ascending: false })\n    \n    if (error) {\n      throw new Error(`Database error: ${error.message}`)\n    }\n    \n    if (!transactions || transactions.length === 0) {\n      return []\n    }\n    \n    // Calculate match scores for each transaction\n    const candidates: ReceiptMatchingCandidate[] = []\n    \n    for (const transaction of transactions) {\n      const matchResult = calculateMatchScore(ocrData, transaction)\n      \n      if (matchResult.score > 0.3) { // Only include reasonable matches\n        candidates.push({\n          transactionId: transaction.id,\n          matchScore: matchResult.score,\n          matchReasons: matchResult.reasons,\n          transaction: {\n            description: transaction.description,\n            amount: transaction.amount,\n            date: transaction.transaction_date,\n            vendor: transaction.vendor_name\n          }\n        })\n      }\n    }\n    \n    // Sort by match score (highest first)\n    candidates.sort((a, b) => b.matchScore - a.matchScore)\n    \n    // Return top 5 matches\n    return candidates.slice(0, 5)\n    \n  } catch (error) {\n    logger.error('Error finding matching transactions', error as Error, {\n      accountantId,\n      ocrVendor: ocrData.vendor.name,\n      ocrAmount: ocrData.amount.value\n    })\n    \n    throw new Error(`Failed to find matching transactions: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\n/**\n * Calculate match score between OCR data and transaction\n */\nfunction calculateMatchScore(\n  ocrData: OCRReceiptData,\n  transaction: any\n): { score: number; reasons: string[] } {\n  let score = 0\n  const reasons: string[] = []\n  \n  // Amount matching (most important factor)\n  const amountDiff = Math.abs(ocrData.amount.value - Math.abs(transaction.amount))\n  const amountThreshold = Math.max(1, Math.abs(transaction.amount) * 0.05) // 5% tolerance\n  \n  if (amountDiff <= amountThreshold) {\n    score += 0.5\n    reasons.push(`Amount match: $${ocrData.amount.value} ≈ $${Math.abs(transaction.amount)}`)\n  } else if (amountDiff <= amountThreshold * 2) {\n    score += 0.3\n    reasons.push(`Amount close: $${ocrData.amount.value} ≈ $${Math.abs(transaction.amount)}`)\n  }\n  \n  // Date matching\n  const ocrDate = new Date(ocrData.date.value)\n  const transactionDate = new Date(transaction.transaction_date)\n  const daysDiff = Math.abs((ocrDate.getTime() - transactionDate.getTime()) / (1000 * 60 * 60 * 24))\n  \n  if (daysDiff <= 1) {\n    score += 0.3\n    reasons.push('Date exact match')\n  } else if (daysDiff <= 3) {\n    score += 0.2\n    reasons.push('Date within 3 days')\n  } else if (daysDiff <= 7) {\n    score += 0.1\n    reasons.push('Date within 1 week')\n  }\n  \n  // Vendor matching\n  if (transaction.vendor_name && ocrData.vendor.name) {\n    const vendorSimilarity = calculateStringSimilarity(\n      ocrData.vendor.name.toLowerCase(),\n      transaction.vendor_name.toLowerCase()\n    )\n    \n    if (vendorSimilarity > 0.8) {\n      score += 0.2\n      reasons.push('Vendor name match')\n    } else if (vendorSimilarity > 0.5) {\n      score += 0.1\n      reasons.push('Vendor name similar')\n    }\n  }\n  \n  return { score: Math.min(score, 1.0), reasons }\n}\n\n/**\n * Calculate string similarity using Levenshtein distance\n */\nfunction calculateStringSimilarity(str1: string, str2: string): number {\n  const matrix = []\n  const len1 = str1.length\n  const len2 = str2.length\n  \n  if (len1 === 0) return len2 === 0 ? 1 : 0\n  if (len2 === 0) return 0\n  \n  // Initialize matrix\n  for (let i = 0; i <= len1; i++) {\n    matrix[i] = [i]\n  }\n  for (let j = 0; j <= len2; j++) {\n    matrix[0][j] = j\n  }\n  \n  // Fill matrix\n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1\n      matrix[i][j] = Math.min(\n        matrix[i - 1][j] + 1,     // deletion\n        matrix[i][j - 1] + 1,     // insertion\n        matrix[i - 1][j - 1] + cost // substitution\n      )\n    }\n  }\n  \n  const maxLen = Math.max(len1, len2)\n  return (maxLen - matrix[len1][len2]) / maxLen\n}\n\n/**\n * Get OCR processing statistics\n */\nexport async function getOCRStatistics(accountantId: string): Promise<{\n  totalProcessed: number\n  successRate: number\n  averageConfidence: number\n  topVendors: Array<{ name: string; count: number }>\n  processingTimes: {\n    average: number\n    p95: number\n  }\n}> {\n  try {\n    const { supabase } = await import('../supabase')\n    \n    const { data: receipts, error } = await supabase\n      .from('receipts')\n      .select('ocr_data, ocr_confidence, processed_at, uploaded_at')\n      .eq('client_id', accountantId) // Assuming client_id links to accountant\n      .not('processed_at', 'is', null)\n      .order('processed_at', { ascending: false })\n      .limit(1000)\n    \n    if (error) {\n      throw new Error(`Database error: ${error.message}`)\n    }\n    \n    if (!receipts || receipts.length === 0) {\n      return {\n        totalProcessed: 0,\n        successRate: 0,\n        averageConfidence: 0,\n        topVendors: [],\n        processingTimes: { average: 0, p95: 0 }\n      }\n    }\n    \n    // Calculate statistics\n    const totalProcessed = receipts.length\n    const successfulProcessing = receipts.filter(r => r.ocr_confidence && r.ocr_confidence > 0.3)\n    const successRate = (successfulProcessing.length / totalProcessed) * 100\n    \n    const avgConfidence = receipts.reduce((sum, r) => sum + (r.ocr_confidence || 0), 0) / totalProcessed\n    \n    // Extract vendor statistics\n    const vendorCounts: Record<string, number> = {}\n    receipts.forEach(receipt => {\n      if (receipt.ocr_data?.vendor?.name) {\n        const vendor = receipt.ocr_data.vendor.name\n        vendorCounts[vendor] = (vendorCounts[vendor] || 0) + 1\n      }\n    })\n    \n    const topVendors = Object.entries(vendorCounts)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10)\n      .map(([name, count]) => ({ name, count }))\n    \n    // Calculate processing times\n    const processingTimes = receipts\n      .filter(r => r.uploaded_at && r.processed_at)\n      .map(r => new Date(r.processed_at!).getTime() - new Date(r.uploaded_at).getTime())\n      .sort((a, b) => a - b)\n    \n    const avgProcessingTime = processingTimes.length > 0 \n      ? processingTimes.reduce((sum, time) => sum + time, 0) / processingTimes.length \n      : 0\n    \n    const p95Index = Math.floor(processingTimes.length * 0.95)\n    const p95ProcessingTime = processingTimes.length > 0 ? processingTimes[p95Index] || 0 : 0\n    \n    return {\n      totalProcessed,\n      successRate: Math.round(successRate * 100) / 100,\n      averageConfidence: Math.round(avgConfidence * 100) / 100,\n      topVendors,\n      processingTimes: {\n        average: Math.round(avgProcessingTime),\n        p95: Math.round(p95ProcessingTime)\n      }\n    }\n    \n  } catch (error) {\n    logger.error('Error calculating OCR statistics', error as Error, { accountantId })\n    throw new Error(`Failed to calculate OCR statistics: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n"